#include <vector>
#include <map>
#include <iostream>
#include <string>

using namespace std;
/*
* "임의의 집합에서 x를 포함하고 크기가 n인 부분집합의 개수와 x을 포함하지 않고 크기가 n-1인 모든 부분집합의 개수는 같다"
* 위 말은 조합론의 기본 원리 중 하나를 반영한 것이다.

임의의 집합 S에서 특정 원소 x를 포함하는 크기가 n인 부분집합을 만드는 방법은,
사실상 x를 제외한 나머지 원소들(S-{x}) 중에서 n-1개를 선택하는 것과 동일하다. 따라서 이 경우의 수는 "S-{x}에서 크기가 n-1인 부분집합을
선택하는 경우의 수"와 동일하게 된다.

이러한 원리는 조합론에서 자주 사용되며, 많은 문제 해결 전략에 적용된다.

*/


/*
* DP[0][0] = 1 - 공집합

Melody = A A B    set = A

i = 1일 때 

DP[1][0] += DP[0][0] ( {} )

A를 고려할 때 A를 추가하지 않은 경우의 수는 이전 멜로디까지만 고려한 경우의 수를 더한다.

DP[1][1] += DP[0][0] ( {A_1} )

A를 고려할 때 A를 추가한 경우의 수는 이전 멜로디까지만 고려한 경우에 A만 추가하면 된다.
예를 들면
A를 선택하지 않고 만들 수 있는 부분집합은 {}공집합 이다. A를 고려한다면 이전 멜로디까지만
고려했을 때(공집합만 존재)의 경우에서 A를 포함시켜주면 된다. {A} 따라서 이전 멜로디까지 가능한 
경우의 수와 현재 멜로디를 포함한 경우의 수는 같게 된다. 이 말은 즉 현재 멜로디를 포함하지 않았을 경우의
수도 이전 멜로디까지만 고려한 경우의 수와 같다는 것이다.

나머지 subset에 대한 경우는 모두 불가능하므로 0이 저장된다.(DP[0][1~4095] = 0)



i = 2일 때

subset = 0 일 때

DP[2][0] += DP[1][0] ( {} )

두 번째 A를 고려할 때 두 번째 A를 추가하지 않을 때 공집합을 만들 수 있는 경우의 수

DP[2][1] += DP[1][0] ( {A_2} )

두 번째 A를 고려할 때 두 번째 A를 추가했을 때의 경우의 수


subset = 1 일 때

DP[2][1] += DP[1][1] ( {A_1},{A_2} )

두 번째 A를 고려할 때 두 번째 A를 추가하지 않았을 때 A를 만들 수 있는 경우의 수

DP[2][1] +=DP[1][1] ( {A_1,A_2} ,{A_1},{A_2} )

두 번째 A를 고려할 때 두번째 A를 추가했을 때 A를 만들 수 있는 경우의 수

subset = 2일 때
subset이 2일 때는 DP[1][2]이 더해질 것인데,  DP[1][2]부터는 0이므로 (B에 대한 부분집합은 아직 없음)
나머지 subset에 대한 DP값은 모두 0이다.

현재 Melody는 중복된 음인 A가 2개 있다. 따라서 A를 추가해도 비트마스크 형태는 1이 될 것이다. 따라서
두 번째 차원 인덱스 1에 값이 누적된다.


i = 3 일 때

subset = 0일 때

DP[3][0] +=DP[2][0] ( {} )

B를 고려했을 때 B를 추가하지 않았을 때 공집합을 만들 수 있는 경우의 수

DP[3][4] +=DP[2][0] ( {B} )

B를 고려했을 때 B를 추가했을 때의 경우의 수

subset = 1일 때

DP[3][1] += DP[2][1] ( {A_1},{A_2},{A_1,A_2} )

B를 고려했을 때 B를 추가하지 않았을 때 A가 들어있는 부분집합의 개수

DP[3][5] += DP[2][1] ( {A_1,B},{A_2,B},{A_1,A_2,B} )

B를 고려했을 때 B를 추가했을 때의 부분집합의 개수

subset이 2,3은 불가능하므로 0으로 채워진다.

subset = 4 일 때

DP[3][4] +=DP[2][4] ( {B} )

B를 추가하지 않고 B를 만들 방법은 이전 멜로디까지는 불가능하다 하지만 현재 멜로디에서 B가 한 번 추가되었기
때문에 DP[3][4]는 값이 1이다.

DP[3][4] +=DP[2][4] ( {B} )

B를 추가했을 경우인데 이전 멜로디에서 B를 만들 수 없었으므로 B를 더할 부분집합이 없다.
마찬가지로 0이 더해진다.

subset = 5일 때

이전 멜로디에서 DP[2][5]는 불가능하므로 마찬가지로 더해지는 부분집합의 경우의 수가 없다.
하지만 현재 멜로디에서 DP[3][5]는 업데이트가 되었으므로 값이 0은 아니다.


이 코드는 다음 규칙을 따른다.

1.현재 음표(melody[i-1])을 선택하지 않는 경우: 이 경우, i-1번째까지의 음표들만으로 subset을 만들어야 한다. 따라서 이전 단계인 DP[i - 1][subset]의 값을 현재 단계에 더해줍니다.
2.현재 음표(melody[i-1])을 선택하는 경우: 이 경우, 현재 음표를 포함시켜야 하므로, subset에 melody[i-1]를 OR 연산한다.(subset | melody[i - 1]). 그리고 이전 단계인 DP[i - 1][subset](현재 음표가 없던 상태에서 subset을 만드는 방법)을 현재 상태에 더해준다.

조합의 기본적인 개념중에 다음이 있다.
"x를 포함하고 크기가 n인 부분집합의 개수와 x을 포함하지 않고 크기가 n-1인 모든 부분집합의 개수는 같다" 

따라서 선택하는 경우와 선택하지 않는 경우에 같은 값을 더해주는 것이다.
집합에서 특정 원소를 포함하는 부분집합의 개수와 그렇지 않은 부분집합의 개수는 동일하다. 이는 "x를 선택하는 경우"와 "x를 선택하지 않는 경우"로 나누어 생각할 수 있기 때문이다.

예를 들어, {A, B, C}라는 집합이 있을 때 'A'를 포함하는 부분집합은 {A}, {A, B}, {A, C}, {A, B, C} 총 4개이고 'A'를 포함하지 않는 부분집합도 {}, {B}, {C}, {B,C} 총 4개이다.

또한 두 경우로 나누는 이유는 동적 프로그래밍에서 최적화를 이루기 위한 목적이다. 만약 모든 부분집합을 
열거하려 한다면 반복 수는 빠르게 증가할 것이다.

{A, B, C}라는 세 개의 음표가 있다고 가정해자. 이 경우에 가능한 모든 부분집합을 동적 프로그래밍으로 생성하는 과정은 다음과 같다.

1.첫 번째 음표 'A'에 대해:
선택하지 않는 경우: 생성된 부분집합은 {}이다.
선택하는 경우: 생성된 부분집합은 {A}이다.
2.두 번째 음표 'B'에 대해:
선택하지 않는 경우: 기존의 부분집합 {}와 {A}에서 'B'가 추가되지 않으므로 그대로 유지된다.
선택하는 경우: 기존의 부분집합 {}와 {A} 각각에 'B'를 추가하여 {}, {A}, {B}, {A,B}이 된다.
3.세 번째 음표 'C'에 대해:
선택하지 않는 경우: 기존의 부분집합 {}, {A}, {B}, {A,B}에서 'C'가 추가되지 않으므로 그대로 유지된다.
선택하는 경우: 기존의 부분집합 {}, {A}, {B}, {A,B} 각각에 'C'를 추가하여 {},{C},{AC},{BC},{ABC},{AB},{AC},{BC}이 된다.
따라서 최종적으로 가능한 모든 부분 집합은 8개({}, A, B, C, AB, AC, BC, ABC)가 되며 이것들은 원래 집합의 크기인 3을 제곱한 값인 2^3과 일치한다.

이렇게 동적 프로그래밍을 통해 각 단계에서 현재 위치의 원소(여기서는 멜로디의 각각의 특정음)가 결과 집합(subset)에 포함될 것인지 아닐 것인지 결정함으로써 문제 해결 전략이 구성된다.

즉, 다시 설명하자면 특정 원소를 포함하는 부분집합의 개수는
해당 원소를 포함하지 않는 경우의 수 + 해당 원소를 포함하는 경우의 수 이다.

만약 BruteForce를 사용한다면 다음과 같다.

두 경우로 나누지 않고, 모든 가능한 부분집합을 직접 열거하려면, 이는 공집합부터 시작하여 각 원소를 하나씩 추가하는 방식으로 이루어질 것이다.

세 개의 원소 A, B, C가 있는 집합을 예로 들어보겠다.

초기 상태에서는 아무런 원소도 선택하지 않은 공집합 {}만 있다.
첫 번째 원소 A를 추가합니다: {}, {A}
두 번째 원소 B를 추가합니다: {}, {A}, {B}, {A,B}
세 번째 원소 C를 추가합니다: {}, {A}, {B}, {C}, {A,B}, {A,C}, {B,C}, {A,B,C}
이 과정에서 각 단계마다 새로운 원소를 기존의 모든 부분집합에 추가해야 한다. 즉, 첫 번째 단계에서는 1번의 연산이 필요하고, 두 번째 단계에서는 2번의 연산이 필요하며, 세 번째 단계에서는 4번의 연산이 필요하다.

따라서 전체적으로 필요한 연산 횟수는 1 + 2 + 4 = 7번이다.

하지만 이러한 방식은 주어진 집합의 크기가 커지면 매우 비효율적이다. 만약 n개의 원소가 있는 집합이라면 각 단계마다 기존 부분집합 수만큼 새로운 부분집합을 생성해야 하므로 전체적으로 필요한 연산 횟수는 (2^n - 1)번이 된다.

즉, 위와 같은 방법은 주어진 문제에 대해 가능한 모든 해를 생성하는 완전 탐색(brute-force) 접근법에 해당되며 계산 복잡성(computational complexity) 면에서 매우 비효율적인 방법이다.
*/



//이 함수는 멜로디와 음 이름 집합을 나타내는 두 개의 정수 벡터를 인자로 받고, 정수 하나를 반환한다.
int CountMelodicPermutations(vector<int> melody, vector<int> set)
{
	//첫 번째 단계는 목표 값을 정의하는 것이다. 목표 값은 비트 단위 연산자를 이용하여 계산한다.
	//음 이름 집합이 { C F# A}라면 목표 값은 다음과 같이 계산된다.

	// C = 3, F# = 9, A = 0 -> 1<<3 , 1<<9 , 1<<0
	//변환 결과 {8,512,1} |=연산 후 target = 521

	unsigned int target = 0;

	for (auto note : set)
	{
		target |= note;
	}
	cout << "target:" << target << endl;

	//이제 2차원 DP 테이블을 정의한다. DP는 2차원 정수 벡터이며, 첫 번째 차원 크기는 (멜로디 길이 + 1)로 지정하고
	//두 번째 차원 크기는 최대 부분집합 값보다 1 큰 정수로 지정한다. 즉, 최대 부분집합 표현 값은 2^12-1 이고 이보다
	//1 큰 정수는 4096이다.
	vector<vector<int>> DP(melody.size() + 1, vector<int>(4096, 0));

	//기저 조건과 재귀 순환식은 다음과 같이 정의할 수 있다.
	/*
	* 기저 조건:
	*	DP(0,0) -> 1
	* 
	* 재귀 순환식:
	*	DP(i,subset) -> DP(i,subset) + DP(i-1,subset)
	*	DP(i,subset U note[i-1]) -> DP(i,subset U note[i]) + DP(i-1,subset)
	* 
	* 인덱스 i는 1부터 멜로디 길이까지 증가한다.
	*/
	
	// 기저 조건 -> 공집합
	DP[0][0] = 1;

	for (int i = 1; i <= melody.size(); i++)
	{
		cout << i << "번 멜로디에 대한 부분집합 계산" << endl;
		for (unsigned int subset = 0; subset < 4096; subset++)
		{
			auto temp_1 = DP[i][subset];

			// (i-1)에서의 결과 더하기
			DP[i][subset] += DP[i - 1][subset];

			if (DP[i][subset] != 0)
			{
				cout << "추가하지 않은 경우" << endl;
				cout << "subset: " << subset << endl;
				cout << endl << "DP[" << i << "][" << subset << "] ("<<temp_1<<") += DP[" << i - 1 << "][" << subset << "] ("<<
					DP[i - 1][subset] <<"): " << DP[i][subset] << endl;
				cout << endl;
			}
			auto temp = DP[i][subset | melody[i - 1]];

			// melody[i-1]를 포함한 부분집합을 고려
			DP[i][subset | melody[i - 1]] += DP[i - 1][subset];

			if (DP[i][subset | melody[i - 1]]!=0)
			{
				cout << "멜로디를 추가한 경우" << endl;
				cout << "subset: " << subset << endl;
				cout << "Melody: " << melody[i-1] << endl;

				cout<<endl<< "DP[" << i << "][" << (subset | melody[i - 1]) << "] ("<< temp<<")"<<
					" += DP["<<i-1<<"]["<<subset<<"] ("<< DP[i - 1][subset] <<"): " << DP[i][subset | melody[i - 1]] << endl;
				cout << endl;
			}
		}
		cout << endl;
	}

	// 최종 해답
	return DP[melody.size()][target];
}

//음계를 비트마스크 형태로 변환한다.
//이 함수는 음이름을 담고 있는 문자열 벡터를 인자로 받고, 이에 대응하는 정수 벡터를 반환한다. A부터 시작하는
//전체 12개 음에 대해 특정 비트가 1로 설정되어 있는 12비트 정수 값을 만들어 매핑한다. 이때 같은 음을 표현하는
//서로 다른 음이름에 대해 같은 정수로 매핑되도록 처리해야 한다. 이를 위해 map을 사용한다.
vector<int> ConvertNotes(vector<string> notes)
{
	map<string, int> M =
	{
		{"A", 0},
		{"A#", 1},
		{"Bb", 1},
		{"B", 2},
		{"Cb", 2},
		{"B#", 3},
		{"C", 3},
		{"C#", 4},
		{"Db", 4},
		{"D", 5},
		{"D#", 6},
		{"Eb", 6},
		{"E", 7},
		{"Fb", 7},
		{"E#", 8},
		{"F", 8},
		{"F#", 9},
		{"Gb", 9},
		{"G", 10},
		{"G#", 11},
		{"Ab", 11}
	};

	vector<int> converted;

	for (auto note : notes)
	{
		converted.push_back(1 << M[note]); // 2의 승수로 매핑
	}

	return converted;
}

int main()
{
	int melodyLength;
	int setLength;

	cin >> melodyLength;

	vector<string> melody(melodyLength);

	for (int i = 0; i < melodyLength; i++)
	{
		cin >> melody[i];
	}

	cin >> setLength;

	vector<string> set(setLength);

	for (int i = 0; i < setLength; i++)
	{
		cin >> set[i];
	}

	int count = CountMelodicPermutations(ConvertNotes(melody), ConvertNotes(set));

	cout << count << endl;

	return 0;
}

/*
 7
 A B C C E C A
 3
 A C E
*/
