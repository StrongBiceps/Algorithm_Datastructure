#include <iostream>

using namespace std;

/*
이 문제는 수열안에서, 증가하는 부분 수열 중 가장 긴 수열을 찾는 문제이다.

1. 부분 수열의 길이를 나타낼 dp table을 하나 생성한다.

2. 첫번째 for문을 돌면서 dp table을 1로 초기화한다.(자기 자신의 길이는 1이므로)

3. 수열의 첫번째 인덱스부터 i번째까지 돌면서 (두번째 for문)

i번째 숫자가 j번째 숫자보다 크다면(=해당 인덱스의 수보다 앞에 위치한 수들을 검사했을 때 자신보다 작다면) dp[i] = max(dp[i],dp[j]+1)이라는 점화식을 이용해 해당 인덱스에서의 증가하는 부분 수열의 길이를 구한다.

예를 들어, 입력이 10 20 10 30 20 50이라면 dp[0]=1이 되고, dp[1]은 max(1, 1+1)을 통해 2가 되고,

dp[2]는 자신보다 작은 수가 없으므로 1, dp[3]은 max(1,2+1)을 통해 3이된다...

4. 두번째 for문이 끝나면, 현재 sum값과 새로 구해진 dp[i]값중 큰 값(= 가장 긴 길이)를 sum에 저장한다. 즉, dp[0]부터 dp[n-1]까지에서 제일 큰 값이 정답이 된다.
*/


//상향식 DP 테이블을 이용하여 해결할 수 있는 문제이다.

//먼저 Outer for 문에서 코드를 진행할 때 DP[i] = 1로 초기화하고 시작한다. 자기 자신만을 고려했을 경우를 의미한다.

//만약 arr[i]가 이전 arr값들에 대해서 가장 작다면 if문에 걸리지 않으므로 자기 자신만을 고려한 1이 DP테이블의 값이 될 것이다.

//Result를 활용하는 이유는 N까지 길이를 고려하지 않고 이전 길이의 수열에서 최댓값이 나올 수 있기 때문이다. 예를 들어

//N == 5일 때 3까지의 길이가 5까지의 길이보다 클 경우 3의 값이 답이 되어야 하기 때문에 수열의 길이를 구하는 과정에서 가장 큰

//값이 정답이 되어야 한다.


int N;
int Result = 0;
int DP[1001], arr[1001];

int main() {

    cin >> N;


    for (int i = 0; i < N; i++) {
        cin >> arr[i];
    }

    for (int i = 0; i < N; i++) {
        DP[i] = 1;
        for (int j = 0; j < i; j++) {
            if (arr[i] > arr[j]) {
                DP[i] = max(DP[i], DP[j] + 1);
            }
        }
        Result = max(Result, DP[i]);
    }

    cout << Result;
}