#include <iostream>
#include <vector>
using namespace std;

int DP[100001] = { 0 };

//먼저 DP 테이블은 수열의 누적합으로 채운다. 하지만 현재까지의 누적합이 현재 인덱스보다 작다면 수열을 현재 인덱스 원소부터 재구성한다.
//즉 DP값은 임의의 길이의 연속된 수열의 누적합이다. 매 반복마다 누적합중에 가장 큰 것으로 Result변수를 업데이트한다. 따라서
//수열이 재구성되더라도 과거에 구성된 수열의 누적합이 더 크다면 그 값을 리턴하면 된다. 만약 수열의 원소를 모두 더해야 가장 큰
//누적합이 발생한다면, DP값은 인덱스마다 계속 커지는 결과가 발생할 것이다. 따라서 마지막 인덱스에서의 DP가 최대값이 될 것이다.
//수열을 재구성하는 이유는 만약 현재까지의 누적합보다 현재 인덱스 값이 더 크다면 현재 인덱스를 선택하는 것이 가장 큰 경우이다.
//지금까지의 누적합은 계속 더해봤자 현재 인덱스를 선택하는 것보다 작다. 따라서 이전 누적합은 버리고 현재 인덱스만 선택하는 것이
//가장 큰 누적합이 될 것이다.

//누적합이 계속 증가하는 상황이라면, 수열을 재구성하지 않고 계속 더해나갈 것이다. 하지만 지금까지의 누적합보다 현재 인덱스 값이
//더 크다면 수열을 재구성해야 한다.

int main()
{
    int N;
    cin >> N;
    vector<int> arr(N, 0);


    for (size_t i = 0; i < arr.size(); ++i)
    {
        cin >> arr[i];
    }

    DP[0] = arr[0];
    int Result = DP[0];

    for (size_t i = 1; i < N; ++i)
    {
        DP[i] = max(arr[i], DP[i - 1] + arr[i]);
        
        if (Result < DP[i])
            Result = DP[i];
    }

    cout << Result;
}