DP[0][0] = 1 - 공집합

Melody = A A B    set = A

i = 1일 때 

DP[1][0] += DP[0][0] ( {} )

A를 고려할 때 A를 추가하지 않은 경우의 수는 이전 멜로디까지만 고려한 경우의 수를 더한다.

DP[1][1] += DP[0][0] ( {A_1} )

A를 고려할 때 A를 추가한 경우의 수는 이전 멜로디까지만 고려한 경우에 A만 추가하면 된다.
예를 들면
A를 선택하지 않고 만들 수 있는 부분집합은 {}공집합 이다. A를 고려한다면 이전 멜로디까지만
고려했을 때(공집합만 존재)의 경우에서 A를 포함시켜주면 된다. {A} 따라서 이전 멜로디까지 가능한 
경우의 수와 현재 멜로디를 포함한 경우의 수는 같게 된다. 이 말은 즉 현재 멜로디를 포함하지 않았을 경우의
수도 이전 멜로디까지만 고려한 경우의 수와 같다는 것이다.

나머지 subset에 대한 경우는 모두 불가능하므로 0이 저장된다.(DP[0][1~4095] = 0)



i = 2일 때

subset = 0 일 때

DP[2][0] += DP[1][0] ( {} )

두 번째 A를 고려할 때 두 번째 A를 추가하지 않을 때 공집합을 만들 수 있는 경우의 수

DP[2][1] += DP[1][0] ( {A_2} )

두 번째 A를 고려할 때 두 번째 A를 추가했을 때의 경우의 수


subset = 1 일 때

DP[2][1] += DP[1][1] ( {A_1},{A_2} )

두 번째 A를 고려할 때 두 번째 A를 추가하지 않았을 때 A를 만들 수 있는 경우의 수

DP[2][1] +=DP[1][1] ( {A_1,A_2} ,{A_1},{A_2} )

두 번째 A를 고려할 때 두번째 A를 추가했을 때 A를 만들 수 있는 경우의 수

subset = 2일 때
subset이 2일 때는 DP[1][2]이 더해질 것인데,  DP[1][2]부터는 0이므로 (B에 대한 부분집합은 아직 없음)
나머지 subset에 대한 DP값은 모두 0이다.

현재 Melody는 중복된 음인 A가 2개 있다. 따라서 A를 추가해도 비트마스크 형태는 1이 될 것이다. 따라서
두 번째 차원 인덱스 1에 값이 누적된다.


i = 3 일 때

subset = 0일 때

DP[3][0] +=DP[2][0] ( {} )

B를 고려했을 때 B를 추가하지 않았을 때 공집합을 만들 수 있는 경우의 수

DP[3][4] +=DP[2][0] ( {B} )

B를 고려했을 때 B를 추가했을 때의 경우의 수

subset = 1일 때

DP[3][1] += DP[2][1] ( {A_1},{A_2},{A_1,A_2} )

B를 고려했을 때 B를 추가하지 않았을 때 A가 들어있는 부분집합의 개수

DP[3][5] += DP[2][1] ( {A_1,B},{A_2,B},{A_1,A_2,B} )

B를 고려했을 때 B를 추가했을 때의 부분집합의 개수

subset이 2,3은 불가능하므로 0으로 채워진다.

subset = 4 일 때

DP[3][4] +=DP[2][4] ( {B} )

B를 추가하지 않고 B를 만들 방법은 이전 멜로디까지는 불가능하다 하지만 현재 멜로디에서 B가 한 번 추가되었기
때문에 DP[3][4]는 값이 1이다.

DP[3][4] +=DP[2][4] ( {B} )

B를 추가했을 경우인데 이전 멜로디에서 B를 만들 수 없었으므로 B를 더할 부분집합이 없다.
마찬가지로 0이 더해진다.

subset = 5일 때

이전 멜로디에서 DP[2][5]는 불가능하므로 마찬가지로 더해지는 부분집합의 경우의 수가 없다.
하지만 현재 멜로디에서 DP[3][5]는 업데이트가 되었으므로 값이 0은 아니다.


이 코드는 다음 규칙을 따른다.

1.현재 음표(melody[i-1])을 선택하지 않는 경우: 이 경우, i-1번째까지의 음표들만으로 subset을 만들어야 한다. 따라서 이전 단계인 DP[i - 1][subset]의 값을 현재 단계에 더해줍니다.
2.현재 음표(melody[i-1])을 선택하는 경우: 이 경우, 현재 음표를 포함시켜야 하므로, subset에 melody[i-1]를 OR 연산한다.(subset | melody[i - 1]). 그리고 이전 단계인 DP[i - 1][subset](현재 음표가 없던 상태에서 subset을 만드는 방법)을 현재 상태에 더해준다.

조합의 기본적인 개념중에 다음이 있다.
"x를 포함하고 크기가 n인 부분집합의 개수와 x을 포함하지 않고 크기가 n-1인 모든 부분집합의 개수는 같다" 

따라서 선택하는 경우와 선택하지 않는 경우에 같은 값을 더해주는 것이다.
집합에서 특정 원소를 포함하는 부분집합의 개수와 그렇지 않은 부분집합의 개수는 동일하다. 이는 "x를 선택하는 경우"와 "x를 선택하지 않는 경우"로 나누어 생각할 수 있기 때문이다.

예를 들어, {A, B, C}라는 집합이 있을 때 'A'를 포함하는 부분집합은 {A}, {A, B}, {A, C}, {A, B, C} 총 4개이고 'A'를 포함하지 않는 부분집합도 {}, {B}, {C}, {B,C} 총 4개이다.

또한 두 경우로 나누는 이유는 동적 프로그래밍에서 최적화를 이루기 위한 목적이다. 만약 모든 부분집합을 
열거하려 한다면 반복 수는 빠르게 증가할 것이다.

{A, B, C}라는 세 개의 음표가 있다고 가정해자. 이 경우에 가능한 모든 부분집합을 동적 프로그래밍으로 생성하는 과정은 다음과 같다.

1.첫 번째 음표 'A'에 대해:
선택하지 않는 경우: 생성된 부분집합은 {}이다.
선택하는 경우: 생성된 부분집합은 {A}이다.
2.두 번째 음표 'B'에 대해:
선택하지 않는 경우: 기존의 부분집합 {}와 {A}에서 'B'가 추가되지 않으므로 그대로 유지된다.
선택하는 경우: 기존의 부분집합 {}와 {A} 각각에 'B'를 추가하여 {}, {A}, {B}, {A,B}이 된다.
3.세 번째 음표 'C'에 대해:
선택하지 않는 경우: 기존의 부분집합 {}, {A}, {B}, {A,B}에서 'C'가 추가되지 않으므로 그대로 유지된다.
선택하는 경우: 기존의 부분집합 {}, {A}, {B}, {A,B} 각각에 'C'를 추가하여 {},{C},{AC},{BC},{ABC},{AB},{AC},{BC}이 된다.
따라서 최종적으로 가능한 모든 부분 집합은 8개({}, A, B, C, AB, AC, BC, ABC)가 되며 이것들은 원래 집합의 크기인 3을 제곱한 값인 2^3과 일치한다.

이렇게 동적 프로그래밍을 통해 각 단계에서 현재 위치의 원소(여기서는 멜로디의 각각의 특정음)가 결과 집합(subset)에 포함될 것인지 아닐 것인지 결정함으로써 문제 해결 전략이 구성된다.

만약 BruteForce를 사용한다면 다음과 같다.

두 경우로 나누지 않고, 모든 가능한 부분집합을 직접 열거하려면, 이는 공집합부터 시작하여 각 원소를 하나씩 추가하는 방식으로 이루어질 것이다.

세 개의 원소 A, B, C가 있는 집합을 예로 들어보겠다.

초기 상태에서는 아무런 원소도 선택하지 않은 공집합 {}만 있다.
첫 번째 원소 A를 추가합니다: {}, {A}
두 번째 원소 B를 추가합니다: {}, {A}, {B}, {A,B}
세 번째 원소 C를 추가합니다: {}, {A}, {B}, {C}, {A,B}, {A,C}, {B,C}, {A,B,C}
이 과정에서 각 단계마다 새로운 원소를 기존의 모든 부분집합에 추가해야 한다. 즉, 첫 번째 단계에서는 1번의 연산이 필요하고, 두 번째 단계에서는 2번의 연산이 필요하며, 세 번째 단계에서는 4번의 연산이 필요하다.

따라서 전체적으로 필요한 연산 횟수는 1 + 2 + 4 = 7번이다.

하지만 이러한 방식은 주어진 집합의 크기가 커지면 매우 비효율적이다. 만약 n개의 원소가 있는 집합이라면 각 단계마다 기존 부분집합 수만큼 새로운 부분집합을 생성해야 하므로 전체적으로 필요한 연산 횟수는 (2^n - 1)번이 된다.

즉, 위와 같은 방법은 주어진 문제에 대해 가능한 모든 해를 생성하는 완전 탐색(brute-force) 접근법에 해당되며 계산 복잡성(computational complexity) 면에서 매우 비효율적인 방법이다.