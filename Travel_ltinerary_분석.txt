F(i) = Σ(j=1 to i-1) F(j) if j + distance(j) ≥ i
여기서 if문이 붙은 이유는

1번 distance[1] = 5
2번 distance[2] = 3
3번 distance[3] = 1
4번 distance[4] = 2

F(3)은 더하지 않는다. 왜냐하면 3에서 5로 바로 갈 수 없기 때문이다.
어차피 F(3)에 대한 경우의 수는 F(4)에서 더해진다.
따라서 5에 도달할 수 있는 지점들에 대해서만 더한다. 만약 5로 바로 도달할 수 없다면,
즉 1번에 도달하여 5번으로
+2번에 도달하여 5번으로
//3번은 5번에 도달할 수 없음(4번에 편입)
+4번에 도달하여 5번으로(3번에 도달하는 경우의 수 포함)
이런 뜻을 수식으로 표현한 것이다.

또한 F(3) = F(2)+F(1) 이므로 피보나치 수열과 비슷한 수식이다. 부분 문제가 중복으로 등장하고 F(3)에 대한 경로가
F(4)를 이루고 F(4)는 F(5)를 이룬다. 동적 프로그래밍의 특성에 해당하고 타뷸레이션을 이용하여 최적화할 수 있다.


sudo 코드는 다음과 같다.

F(n) -> n번째 도시에 도착하는 방법의 수

F(i) = 
	if i == N:
		return 1
	Otherwise:
		retsult = 0

		for j = 1 to distance[i]:
			result=result + F(i+j)
	return result

top down solution

하위 재귀의 값이 상위 재귀에 사용된다. - 하향식 재귀

1 2 3 4 5
1 2 4 5
1 2 5
1 3 4 5
1 4 5
1 5

출발점이 0인데 0은 1로만 갈 수 있으므로 1에서 출발했다고 가정하고
2에서 5를 갈 수 있는 경우는 3가지,
3에서 5를 갈 수 있는 경우는 1가지,
4도 1가지
5로 바로 가는 방법 1가지

위 내용을 0(진짜 출발지) 에서 출발했다고 한다면 , 1에서 5로 가는 방법이 0에서 1로 가는 방법의 경우의 수로 바뀐다.
즉 DP[5]+=DP[1](0은 1번 지점을 뜻한다) 인데 DP[1]=DP[0]이다.

총 6가지이다. 

F(1)= 6 (1)에서 5로 갈 수 있는 경우 6가지 -이 아래로는 1을 제외한 각 지점에서 5까지 갈 수 있는 경우의 수이다.
	result=result+F(2)
		      F(2) = 3 (2)에서 5로 갈 수 있는 경우 3가지
				result=result+F(3)
					      F(3) = 1
						result=result+F(4)
							      F(4) = 1
							      result=result+F(5)
								            F(5)=return 1
           			result(1)+=F(4)
					F(4) = 1 - 중복
           			result(2)+=F(5)
					F(5) = 1 - 중복
	result(3)+=result+F(3) (3)에서 가는 경우 1가지
		          F(3) = 1 - 중복
	result(4)+=result+F(4)
			  F(4) = 1 - 중복
	result(5)+=result+F(5)
			  F(5) = 1 - 중복
	최종 result = 6	


이제 위 재귀식을 상향식으로 바꿔야 한다. 이전 결과가 다음 결과에 영향을 미치므로 상향식 재귀이다.
이제 타뷸레이션 최적화 방식의 형태가 드러나고 있다.

DP->N+1 크기의 배열
DP[0] = 1 (시작 지점에 도달 방법은 하나이다.)

for i =0 to N-1:
	for j = 1 to distance[i]:
		DP[i+j]+=DP[i]
return DP[N]


*Bottom-up solution 

아래 상향식 재귀에서 각 지점이 도달할 수 있는 지점들에 대해서 경우의 수(DP)가 더해지고 있다.
즉 2중첩 반복문이 필요한 방법인 것이다. 하지만 distance를 reverse하여 목적지부터 계산하게 되면
부분합인 sum 배열을 통해서 2중첩 반복을 제거하고 1개의 반복문만 사용할 수 있다.

i = 0일 때

DP[1]+=DP[0] 1

i = 1일 떄

DP[2]+=DP[1] 1
DP[3]+=DP[1] 1
DP[4]+=DP[1] 1
DP[5]+=DP[1] 1

i = 2일 떄

DP[3]+=DP[2] 2
DP[4]+=DP[2] 2
DP[5]+=DP[2] 2

i = 3일 때

DP[4]+=DP[3] 4

i = 4일 떄

DP[5]+=DP[4] 6

즉 5에 도달하는 방법은 각 지점에 도달하는 방법을 모두 더한 값이다.
단 5로 도달할 수 없는 지점은 더하지 않아야 한다. 다른 지점의 경로에 편입되기 때문이다.
위 로직에서는 3은 5까지 갈 수 없으므로 DP[5]에는 더해지지 않고 DP[4]에 더해져서 계산된다.

다시 아래 경우에서 생각을 해본다.

1번 distance[1] = 5
2번 distance[2] = 3
3번 distance[3] = 1
4번 distance[4] = 2

일단 위 경우는 지점 6까지 있는 경우에서 5까지 도달할 수 있는 경우를 생각한 것이므로
다음과 같이 5가 마지막 지점이 되게 수정한다.

1번 distance[1] = 4
2번 distance[2] = 3
3번 distance[3] = 1
4번 distance[4] = 1

재귀는 식의 코드는 다음과 같다. reverse를 통해서 distance 배열을 뒤집으면 목적지부터 계산할 수 있다.

reverse(distance.begin(),distance.end())

DP[0] = 1; //DP[0] => 5번 지점까지 도달하는 경우의 수 (시작 지점까지 도달하는 경우의 수와 같다)
	   //뒤집었을 때는 시작점 0을 신경쓸 필요가 없다. 어차피 0에서부터 무조건 1에 도달하기 때문이다.
	   //또한 뒤집었을 때는 목적지부터 계산하므로 DP[0]이 목적지까지 도달하는 경우의 수로 바뀌기 때문이다.(또한 해당 정점에서 목적지까지 바로 도달하는 경우의 수로 바뀐다 두 가지 의미를 갖는다)
	   //뒤집지 않았을 경우에는 DP[0]=1로 설정을 해줘야 거리가 하나인 경우가 전달될 수 있다.
	   //0->1->2->3 일 때 각 거리가 1이라고 하면 DP[0]=0이라고 한다면 (시작점 뒤는 없으므로 시작점까지 가는 경우는 없다고 이해했을 때) DP[1]이 0으로 설정되어 버린다.
	   //또한 상향식 재귀 특성상 DP[0]=1이라는 기저 조건이 필요하다.
	
for(int i = 1; i <= n; ++i)
{
	int dist  = distance[i-1];
	for(int j = 1; j <= dist; ++j)
	{
		DP[i]=DP[i]+DP[i-j]
	}
}

return DP[n];

재귀를 따라가보자.

distance 배열의 원소는 1 1 3 4이다.

거꾸로 계산을 하면 더 이상 DP[4]를 제외하고는 나머지 DP값은 지점에 도달할 수 있는 경우의 수와 맞지 않는다.
즉 DP값들은 해당 지점에서 목적지까지 가는 경우의 수로 바뀐다.
아래 결과를 보면 DP[1],DP[2]는 맞지만 DP[3]은 4번 지점까지의 도달 경우의 수인데 3으로 나온다. 원래 값은 4이다.
하지만 마지막 DP[4]는 정확하게 6이 나온다. 

*i=1일 떄 (4번 지점의 거리) 4번에서 출발하여 5번까지 도달할 수 있는 경우의 수를 의미한다.

dist = distance[0]
dist->1

j반복


DP[1]=DP[1]+DP[0]
DP[1]=1

*i=2일 때 (3번 지점의 거리) 3번에서 출발하여 5번까지 도달할 수 있는 경우의 수

dist=distance[1]
dist->1

j반복

DP[2]=DP[2]+DP[1] 
- DP[1]은 4번에서 5번으로 갈 수 있는 경우의 수이다. 3번에서는 거리가 1이므로 4번까지 갈 수 있다. 따라서 4번의 경우의 수를 더하는 것이
 3번에서 출발하여 5번까지 가는 경우의 수가 된다. 어차피 3은 4까지밖에 갈 수 없기 때문이다. 
그럼 4에서 출발하는 경우의 수와 중복되는 거 아닌가 하는 의문이 들 수 있는데 4에서 출발하는 것과 3에서 출발하는 것은 다른 경우의 수이다.
 만약 거리가 2라면, DP[2]+=DP[0]까지가 계산되어 2가지의 경우의 수가 계산될 것이다
DP[2]=1


*i=3일 때 (2번 지점의 거리) 2번 지점에서 출발하여 5번 지점까지 도달할 수 있는 경우의 수

dist=distance[2]
dist->3

j반복

DP[3] = DP[3]+DP[0] - 바로 5번으로 가는 경우의 수
DP[3]->1

DP[3] = DP[3]+DP[1] - 3번으로 가서 5번으로 가는 경우의 수
DP[3]->2

DP[3] = DP[3]+DP[2] - 4번으로 가서 5번으로 가는 경우의 수
DP[3]->3

*i=4일 때 (1번 지점의 거리) 1번 지점에서 출발하여 5번 지점까지 도달할 수 있는 경우의 수

dist = distance[3]
dist->4

j반복

DP[4] = DP[4]+DP[0] - 5번으로 바로 가는 경우의 수
DP[4] = DP[4]+DP[1] - 4번으로 가서 5번으로 가는 경우의 수
DP[4] = DP[4]+DP[2] - 3번으로 가서 5번으로 가는 경우의 수
DP[4] = DP[4]+DP[3] - 2번으로 가서 5번으로 가는 경우의 수
DP[4] -> DP[3]+DP[2]+DP[1]+DP[0] 1번은 각 지점에 도달할 수 있으므로 각 지점의 경우의 수를 모두 더하면 된다. DP[0]은 5로 바로 가는 것이 된다.
DP[4] -> 3 + 1 + 1 + 1이 된다.

sum을 이용하면 2중첩 반복문을 제거할 수 있다.

먼저 위 경우를 sum을 이용한 코드에 적용시키면 다음과 같은 결과를 출력한다.

1번째 반복-> 4번 지점에서 목적지까지 계산
dist[0]: 1
sum: sums[1] - sums[0] : 1
4번 지점에서 5번 지점까지의 경우의 수: 1
DP[1] = DP[1] + 1 : 1
sums[2] = sums[1] + DP[1]: 2

2번째 반복-> 3번 지점에서 목적지까지 계산
dist[1]: 1
sum: sums[2] - sums[1] : 1
3번 지점에서 4번 지점까지의 경우의 수: 1
DP[2] = DP[2] + 1 : 1
sums[3] = sums[2] + DP[2]: 3

3번째 반복-> 2번 지점에서 목적지까지 계산
dist[2]: 3
sum: sums[3] - sums[0] : 3
2번 지점에서 5번 지점까지의 경우의 수: 3
DP[3] = DP[3] + 3 : 3
sums[4] = sums[3] + DP[3]: 6

4번째 반복-> 1번 지점에서 목적지까지 계산
dist[3]: 4
sum: sums[4] - sums[0] : 6
1번 지점에서 5번 지점까지의 경우의 수: 6
DP[4] = DP[4] + 6 : 6
sums[5] = sums[4] + DP[4]: 12

일단 4번째 반복을 보면 sum[4]에서 sum[0]을 빼주고 있다. 즉 1번 지점은 모든 지점에 도달할 수 있다.
다시 말하면 지금 까지 계산된 모든 경로에 1만 추가하면 된다. 따라서 모든 경우의 수가 1에서 출발하는 경우의 수로 바뀐다.

2 3 4 5   
2 4 5
2 5
3 4 5
4 5
5
->

1 2 3 4 5
1 2 4 5
1 2 5
1 3 4 5
1 4 5
1 5


3번째 반복을 보면 마찬가지로 2지점은 3,4,5모든 지점에 도달할 수 있다. 따라서 각 지점에서 계산된 모든 경우의 수는 곧 2지점의 경우의
수로 바뀐다.

3 4 5
4 5
5 (이렇게 5로 바로 가는 경우를 계산하기 위해 sums[1]과 DP[0]을 1로 설정한다.)
->

2 3 4 5
2 4 5
2 5

2번째 반복을 보면 3번 지점은 4번 지점으로만 갈 수 있다. 따라서 4번을 거쳐서 가는 경우만 남겨놓고 나머지 경우의 수는 빼줘야 한다.
sums[2](4번의 경우의 수)-sums[1](5번의 경우의 수) 이 수식을 해석하면 3번에서는 distance가 1이므로 sums[2-1]을 빼주고 sums[2]만 남겨 놓는다.

4번째 반복을 보면 4번 지점은 5번으로 바로 갈 수 있다. 또 4번 지점에서의 거리는 1과 0만 가능하므로(도착지 바로 직전 지점이므로) sums[1](5로 바로 가는 경우)-sums[0]=1이다.

sums에 대한 사용을 정리해보면,
각 지점에 대해서 distance값에 따라 sums[i]-sums[i-distance]를 해주는 이유는 sums[i]는 지금까지 각 지점이 목적지까지 도달할 수 있는 경우의 수가 모두 누적된 값이므로
여기서 현재 지점이 도달할 수 있는 지점에 대해서만 경우의 수를 남겨놓기 위해서 sums[i-distance]값을 빼주는 것이다. 이렇게 제거한 경우의 수가 DP[i]이다.
 이렇게 목적지부터 계산하는 방법과 부분합을 사용하면 2중 반복문을 제거할 수 있다.

sums[1] -> 5로 바로 갈 수 있는 경우의 수
sums[2] -> sums[1]+4에서 5로 갈 수 있는 경우의 수
sums[3] -> sums[2]+3에서 5로 갈 수 있는 경우의 수
sums[4] -> sums[3]+2에서 5로 갈 수 있는 경우의 수

이렇게 부분합을 사용하지 않으면 n의 값이 증가함에 따라 2중 반복문은 엄청난 수의 반복을 하게 될 것이다. 따라서 이러한 방법을 통해서 안쪽 반복문을 제거할 수 있다.

