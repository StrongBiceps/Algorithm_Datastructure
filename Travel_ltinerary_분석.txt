F(i) = Σ(j=1 to i-1) F(j) if j + distance(j) ≥ i
여기서 if문이 붙은 이유는

1번 distance[1] = 5
2번 distance[2] = 3
3번 distance[3] = 1
4번 distance[4] = 2

F(3)은 더하지 않는다. 왜냐하면 3에서 5로 바로 갈 수 없기 때문이다.
어차피 F(3)에 대한 경우의 수는 F(4)에서 더해진다.
따라서 5에 도달할 수 있는 지점들에 대해서만 더한다. 만약 5로 바로 도달할 수 없다면,
즉 1번에 도달하여 5번으로
+2번에 도달하여 5번으로
//3번은 5번에 도달할 수 없음(4번에 편입)
+4번에 도달하여 5번으로(3번에 도달하는 경우의 수 포함)
이런 뜻을 수식으로 표현한 것이다.

또한 F(3) = F(2)+F(1) 이므로 피보나치 수열과 비슷한 수식이다. 부분 문제가 중복으로 등장하고 F(3)에 대한 경로가
F(4)를 이루고 F(4)는 F(5)를 이룬다. 동적 프로그래밍의 특성에 해당하고 타뷸레이션을 이용하여 최적화할 수 있다.


sudo 코드는 다음과 같다.

F(n) -> n번째 도시에 도착하는 방법의 수

F(i) = 
	if i == N:
		return 1
	Otherwise:
		retsult = 0

		for j = 1 to distance[i]:
			result=result + F(i+j)
	return result

top down solution

하위 재귀의 값이 상위 재귀에 사용된다. - 하향식 재귀

1 2 3 4 5
1 2 3 4
1 2 5
1 3 4 5
1 4 5
1 5

출발점이 0인데 0은 1로만 갈 수 있으므로 1에서 출발했다고 가정하고
2에서 5를 갈 수 있는 경우는 3가지,
3에서 5를 갈 수 있는 경우는 1가지,
4도 1가지
5로 바로 가는 방법 1가지

위 내용을 0(진짜 출발지) 에서 출발했다고 한다면 , 1에서 5로 가는 방법이 0에서 1로 가는 방법의 경우의 수로 바뀐다.
즉 DP[5]+=DP[1](0은 1번 지점을 뜻한다) 인데 DP[1]=DP[0]이다.

총 6가지이다. 

F(1)= 6 (1)에서 5로 갈 수 있는 경우 6가지 -이 아래로는 1을 제외한 각 지점에서 5까지 갈 수 있는 경우의 수이다.
	result=result+F(2)
		      F(2) = 3 (2)에서 5로 갈 수 있는 경우 3가지
				result=result+F(3)
					      F(3) = 1
						result=result+F(4)
							      F(4) = 1
							      result=result+F(5)
								            F(5)=return 1
           			result(1)+=F(4)
					F(4) = 1 - 중복
           			result(2)+=F(5)
					F(5) = 1 - 중복
	result(3)+=result+F(3) (3)에서 가는 경우 1가지
		          F(3) = 1 - 중복
	result(4)+=result+F(4)
			  F(4) = 1 - 중복
	result(5)+=result+F(5)
			  F(5) = 1 - 중복
	최종 result = 6	


이제 위 재귀식을 상향식으로 바꿔야 한다. 이전 결과가 다음 결과에 영향을 미치므로 상향식 재귀이다.
이제 타뷸레이션 최적화 방식의 형태가 드러나고 있다.

DP->N+1 크기의 배열
DP[0] = 1 (시작 지점에 도달 방법은 하나이다.)

for i =0 to N-1:
	for j = 1 to distance[i]:
		DP[i+j]+=DP[i]
return DP[N]


*Bottom-up solution

i = 0일 때

DP[1]+=DP[0] 1

i = 1일 떄

DP[2]+=DP[1] 1
DP[3]+=DP[1] 1
DP[4]+=DP[1] 1
DP[5]+=DP[1] 1

i = 2일 떄

DP[3]+=DP[2] 2
DP[4]+=DP[2] 2
DP[5]+=DP[2] 2

i = 3일 때

DP[4]+=DP[3] 4

i = 4일 떄

DP[5]+=DP[4] 6

즉 5에 도달하는 방법은 각 지점에 도달하는 방법을 모두 더한 값이다.
단 5로 도달할 수 없는 지점은 더하지 않아야 한다. 다른 지점의 경로에 편입되기 때문이다.
위 로직에서는 3은 5까지 갈 수 없으므로 DP[5]에는 더해지지 않고 DP[4]에 더해져서 계산된다.

다시 아래 경우에서 생각을 해본다.

1번 distance[1] = 5
2번 distance[2] = 3
3번 distance[3] = 1
4번 distance[4] = 2

일단 위 경우는 지점 6까지 있는 경우에서 5까지 도달할 수 있는 경우를 생각한 것이므로
다음과 같이 5가 마지막 지점이 되게 수정한다.

1번 distance[1] = 4
2번 distance[2] = 3
3번 distance[3] = 1
4번 distance[4] = 1

재귀는 식의 코드는 다음과 같다. reverse를 통해서 distance 배열을 뒤집으면 목적지부터 계산할 수 있다.

reverse(distance.begin(),distance.end())

DP[0] = 1; //DP[0] => 5번 지점까지 도달하는 경우의 수 (시작 지점까지 도달하는 경우의 수와 같다)
	   //뒤집었을 때는 시작점 0을 신경쓸 필요가 없다. 어차피 0에서부터 무조건 1에 도달하기 때문이다.
	   //또한 뒤집었을 때는 목적지부터 계산하므로 DP[0]이 목적지까지 도달하는 경우의 수로 바뀌기 때문이다.(또한 해당 정점에서 목적지까지 바로 도달하는 경우의 수로 바뀐다 두 가지 의미를 갖는다)
	   //뒤집지 않았을 경우에는 DP[0]=1로 설정을 해줘야 거리가 하나인 경우가 전달될 수 있다.
	   //0->1->2->3 일 때 각 거리가 1이라고 하면 DP[0]=0이라고 한다면 (시작점 뒤는 없으므로 시작점까지 가는 경우는 없다고 이해했을 때) DP[1]이 0으로 설정되어 버린다.
	   //또한 상향식 재귀 특성상 DP[0]=1이라는 기저 조건이 필요하다.
	
for(int i = 1; i <= n; ++i)
{
	int dist  = distance[i-1];
	for(int j = 1; j <= dist; ++j)
	{
		DP[i]=DP[i]+DP[i-j]
	}
}

return DP[n];

재귀를 따라가보자.

distance 배열의 원소는 1 1 3 4이다.

거꾸로 계산을 하면 더 이상 DP[4]를 제외하고는 나머지 DP값은 지점에 도달할 수 있는 경우의 수와 맞지 않는다.
즉 DP값들은 해당 지점에서 목적지까지 가는 경우의 수로 바뀐다.
아래 결과를 보면 DP[1],DP[2]는 맞지만 DP[3]은 4번 지점까지의 도달 경우의 수인데 3으로 나온다. 원래 값은 4이다.
하지만 마지막 DP[4]는 정확하게 6이 나온다. 

*i=1일 떄 (4번 지점의 거리) 4번에서 출발하여 5번까지 도달할 수 있는 경우의 수를 의미한다.

dist = distance[0]
dist->1

j반복


DP[1]=DP[1]+DP[0]
DP[1]=1

*i=2일 때 (3번 지점의 거리) 3번에서 출발하여 5번까지 도달할 수 있는 경우의 수

dist=distance[1]
dist->1

j반복

DP[2]=DP[2]+DP[1] 
- DP[1]은 4번에서 5번으로 갈 수 있는 경우의 수이다. 3번에서는 거리가 1이므로 4번까지 갈 수 있다. 따라서 4번의 경우의 수를 더하는 것이
 3번에서 출발하여 5번까지 가는 경우의 수가 된다. 어차피 3은 4까지밖에 갈 수 없기 때문이다. 
그럼 4에서 출발하는 경우의 수와 중복되는 거 아닌가 하는 의문이 들 수 있는데 4에서 출발하는 것과 3에서 출발하는 것은 다른 경우의 수이다.
 만약 거리가 2라면, DP[2]+=DP[0]까지가 계산되어 2가지의 경우의 수가 계산될 것이다
DP[2]=1


*i=3일 때 (2번 지점의 거리) 2번 지점에서 출발하여 5번 지점까지 도달할 수 있는 경우의 수

dist=distance[2]
dist->3

j반복

DP[3] = DP[3]+DP[0] - 바로 5번으로 가는 경우의 수
DP[3]->1

DP[3] = DP[3]+DP[1] - 3번으로 가서 5번으로 가는 경우의 수
DP[3]->2

DP[3] = DP[3]+DP[2] - 4번으로 가서 5번으로 가는 경우의 수
DP[3]->3

*i=4일 때 (1번 지점의 거리) 1번 지점에서 출발하여 5번 지점까지 도달할 수 있는 경우의 수

dist = distance[3]
dist->4

j반복

DP[4] = DP[4]+DP[0] - 5번으로 바로 가는 경우의 수
DP[4] = DP[4]+DP[1] - 4번으로 가서 5번으로 가는 경우의 수
DP[4] = DP[4]+DP[2] - 3번으로 가서 5번으로 가는 경우의 수
DP[4] = DP[4]+DP[3] - 2번으로 가서 5번으로 가는 경우의 수
DP[4] -> DP[3]+DP[2]+DP[1]+DP[0] 1번은 각 지점에 도달할 수 있으므로 각 지점의 경우의 수를 모두 더하면 된다. DP[0]은 5로 바로 가는 것이 된다.
DP[4] -> 3 + 1 + 1 + 1이 된다.
