# Algorithm_Datastructure

# 2023.08.02

# Map_Reduce using STL (STL을 이용)

맵은 컨테이너 C를 입력으로 받아, 컨테이너의 모든 원소에 함수 f(x)를 적용하는 것이다. 예를 들어 f(x)=x^2함수를 사용할 경우에 대한 맵 연산을 다음에 나타낸다.
1 2 3 4 5 6 7
->1 4 9 16 25 36 49

리듀스는 컨테이너 C의 모든 원소 x에 함수 f(acc,x)를 적용하여 하나의 값으로 축약하는 연산이다. 예를 들어 f(acc,x)=acc+x 함수를 사용할 경우에 대한 리듀스 연산의 예를 다음에 나타낸다. 
1 2 3 4 5 6 7
->28

c++ 표준 라이브러리는 맵과 리듀스 연산을 std::transform()과
std::accumulate함수로 제공한다. c++17에서는 std::reduce()도 제공한다.
accumulate()는 기본적으로 누적 연산을 수행하기 때문에 리듀스 연산의 제한된 형태라고 볼 수 있다. c++17을 지원하는 최신 컴파일러에서는 더 일반적이며 병렬 처리도 지원하는 reduce()를 사용할 수 있다.

# Map_Reduce_PrimeNumber

맵 리듀스 모델을 사용하여 프로그램을 작성하려면 원하는 연산을 맵과 리듀스 두 단계로 표현할 수 있어야 한다. 맵(또는 파티션) 단계에서는 입력을 중간 단계의 <키,값>쌍으로 표현하고, 리듀스 단계에서는 중간 단계의 <키,값>쌍을 원하는 방식으로 결합하여 최종 결과를 생성한다.
하둡은 맵과 리듀스 연산을 확장성 있고 분산 처리가 가능하게 만듦으로써 컴퓨터 클러스터에서 동작할 수 있고 연산 시간을 크게 단축시킬 수 있다.

해당 코드는 양의 정수 N이 있을 때 1에서 N사이의 소수를 찾으려고 한다. 맵 리듀스 프로그래밍 모델과 멀티 스레드를 사용하여 이 문제를 해결한다.

# PPL (병렬 처리 라이브러리)

병렬 처리 라이브러리에서 제공하는 함수들과 STL 함수의 맵 작업의 속도를 비교하는 MS 레퍼런스의 코드이다. 
여러 프로세스를 처리하는 병렬 처리 방식을 사용하는 parallel_for_each함수가 더 빠른 것을 확인할 수 있다.

병렬 처리는 대규모의 데이터를 처리할 때 유용하게 사용되는 개념이다.

# Student_grade 

학생들의 정보를 저장하고 평균과 총점, 정보를 출력할 수 있는 클래스를 구현했다.

# 2023.08.03

# Greedy Algorithm (shortest -job-first-scheduling)

은행 창구에 줄을 서서 순서를 기다리는 사람들이 있다. 하필이면 은행이 바쁜 날이라서 하나의 창구에서만 업무를 보고 있고, 대기열에 N명의 사람들이 기다리고 있다. 이들은 서로 다른 용무로 방문했기 때문에 일 처리에 필요한 시간은 사람들마다 다르다. 대기열에 기다리고 있던 모든 사람이 매우 합리적이어서 평균 대기 시간이 최소화될 수 있도록 대기 순서를 다시 정하는 것에 동의했다. 그래서 이제 대기 순서를 어ᄄᅠᇂ게 바꿔야 하는지를 결정해야 한다.

일 처리 시간 		8 1 2 4 9 2 3 5
기다려야 하는 시간  0 8 9 11 15 24 26 29
평균 대기 시간 15.25

평균 대기 시간을 최소화하는 것이 목표이기 때문에 가능한 많은 사람의 대기 시간을 줄일 수 있는 방법을 찾아야 한다. 모든 사람의 대기 시간을 줄이려면 일 처리가 가장 빨리 끝나는 사람을 맨 앞에 세워야 한다. 이러한 방식을 반복하면 다음과 같이 재정렬할 수 있다.

일 처리 시간1 2 2 3 4 5 8 9 기다려야 하는 시간
0 1 3 5 8 12 17 25
평균 대기 시간 8.875

# Fractional_kanpsack_problem (분할 가능 배낭 문제)

0-1 배낭 문제라고도 부르는 일반 배낭 문제는 NP-완전 문제로 알려져 있어서 다항 시간 솔루션을 사용할 수 없다. 그러나 0-1배낭 문제를 조금 변경한 분할 가능 배낭 문제는 그리디 방식으로 해결할 수 있다. 이 두 가지 문제를 살펴보면서 문제 정의의 작은 차이가 문제 해결 방법에 큰 변화를 가져올 수 있다는 것을 알 수 있다.

# 
<0-1배낭 문제>

물건들의 집합 O={O1,O2,O3...,On)이 있고, 여기서 I번째 물건 Oi의 무게는 Wi이고 가격은 Vi이다. 그리고 최대 무게를 T까지 견딜 수 있는 가방이 하나 주어진다. 이제 물건들을 가방에 담아야 하는데, 가방에 넣은 물건들의 가격 합이 최대가 되도록 물건을 선택하려 한다. 단, 물건들의 무게 합이 T를 넘지 않아야 한다.

배낭 문제는 NP-완전 문제로 알려져 있고, 이 문제에 대한 다항 시간 솔루션은 알려져 있지 않다. 결과적으로 모든 가능한 조합을 조사하여 무게가 T를 넘지 않는 가장 높은 가격을 찾아내야 한다. 
#
<분할 가능 배낭 문제>

이번에는 앞서 설명한 일반 배낭 문제를 조금 바꿔본다. 즉, 주어진 물건을 원하는 형태로 얼마든지 분할할 수 있고, 각 물건의 일부분만을 배낭에 담을 수 있다고 가정한다. 실생활의 예를 들면, 상인이 기름,곡물,밀가루와 같은 품목을 다룬다고 생각하면 된다. 이 경우 각 품목을 원하는 양만큼 덜어내서 배낭에 담을 수 있다.

# interval_scheduling_solution(작업 스케줄링 문제)

각각의 작업은 ID로 구분되고, 특정 시간 시작 시간과 종료 시간 사이에만 수행할 수 있다. 정해진 시간 안에 최대한 많은 수의 작업을 완료하는 것이 목표이다. 이 경우 어떤 작업을, 어떤 순서로 수행해야 할까? 특정 시점에 오직 하나의 작업만 수행할 수 있다.

1.각각의 작업은 고유한 ID, 시작 시간, 종료 시간을 가진다. 이러한 작업을 표현할 구조체를 생성한다.

2.N개의 작업을 포함하는 std::list를 생성한다. 각 작업은 1부터 N까지의 고유한 ID를 가진다. 시작 시간과 종료 시간은 임의의 정수로 설정한다.

3.다음과 같은 방식으로 스케줄링 함수를 작성한다.


  a.종료 시간을 기준으로 전체 작업 리스트를 정렬한다.

  b.그리디 방식으로 가장 빠른 종료 시간을 갖는 작업을 선택한다.

  c.현재 선택된 작업과 시간이 겹치는 작업은 모두 제거한다. 즉, 현재 작업 종료 시간보다 먼저 시작하는 작업은 제거한다.

  d.리스트에 작업이 남아 있다면 b로 이동한다. 그렇지 않으면 선택된 작업들로 구성된 벡터를 반환한다.

# MST (Minimum Spanning Tree)

모든 문제에 그리디 방식을 적용할 수 있는 것은 아니다. 최적 부분 구조와 그리디 선택이라는 두 가지 속성을 모두 갖는 문제만 그리디 접근 방식으로 최적의 솔루션을 구할 수 있다.

*최적 부분 구조: 주어진 문제 p에 대한 최적의 솔루션이 p의 부분 문제들의 최적의 솔루션으로 구성될 경우, 문제 p가 최적의 부분 구조를 갖는다고 말한다.

*그리디 선택: 주어진 문제 P에 대한 지역적 최적 솔루션을 반복적으로 선택하여 전체 최적 솔루션을 구할 수 있는 경우, 문제 p가 그리디 선택 속성을 갖는다고 말한다.

최적 부분 구조와 그리디 선택 속성에 대해 이해하기 위해, 크루스칼 최소 신장 트리 알고리즘에 대해 알아본다.

최소 신장 트리는 다음과 같이 정의할 수 있다. “정점(vertex)의 집합 V와 가중치를 갖는 에지(Edge)의 집합E로 구성된 그래프 G=<V,E>가 주어질 때, 모든 정점을 연결하고 연결된 에지의 가중치 합이 최소인 트리 T를 구하시오.”

실생활에서 찾아볼 수 있는 MST 문제의 예로 상수도관 네트워크 또는 도로 네트워크 설계가 있다. 상수도관 네트워크 설계의 경우, 모든 사람에게 수돗물이 전달되어야 하고 전체 상수도관의 길이는 최소가 되는 것이 좋다. 도로 네트워크를 설계할 때는 모든 필요한 지점에 도로가 연결되어야 하고 도로의 전체 길이는 최소가 되는 것을 목표로 한다. 

최소 신장 트리T를 구하는 방법은 다음과 같다.

1.그래프 G의 모든 에지를 최소 힙 H에 추가한다.

2.H로부터 에지 e를 하나 꺼낸다. 당연히 e는 모든 에지 중에서 가장 가중치가 작은 에지이다.

3.e의 양 끝 정점이 이미 T에 있을 경우, e로 인해 T에서 사이클이 발생할 수 있다. 그러므로 이런 경우에는 e를 버리고 2단계로 이동한다.

4.최소 신장 트리 T에 e를 추가하고, 2단계로 이동한다.

이 알고리즘은 2단계부터 4단계까지를 반복하면서 가장 작은 가중치의 에지를 찾고, 이 에지에 의해 사이클이 발생하지 않으면 해당 에지와 양 끝 정점을 최종 솔루션에 추가한다. 이렇게 선택된 에지와 정점은 최소 신장 트리를 구성한다. 이 알고리즘은 매 반복마다 최소 에지 가중치를 선택하기 때문에 그리디 방식이라고 할 수 있다. 이 알고리즘을 크루스칼 최소 신장 트리 알고리즘이라고 한다.

최적 부분 구조: 귀류법을 사용하여 최적 부분 구조 속성을 증명해본다. 이를 위해 MST 문제가 최적 부분 구조 속성을 가지지 않는다고 가정한다. 즉, 최소 신장 트리가 더 작은 최소 신장 트리의 집합으로 구성되지 않는다고 가정한다.

1. 그래프 G의 정점으로 구성된 최소 신장 트리 T가 있다고 가정한다. T에서 에지 e를 하나 선택하여 제거한다. e를 제거하면 T가 더 작은 트리인 T1과 T2로 나눠진다.

2.MST 문제가 최적 부분 구조 속성을 갖지 않는다고 가정했으므로 T1보다 작은 가중치를 갖는 신장 트리 T1'이 존재해야 한다. 이 신장 트리 T1'과 T2를 에지 e로 연결한 새로운 신장 트리를 T'이라고 한다.

3. T'의 가중치가 T의 가중치보다 작으므로 처음에 T가 최소 신장 트리라고 가정했던 사실이 틀리게 된다.

정리하면 최소 신장 트리 T의 부분 구조인 T'의 가중치가 더 작으므로 T'도 신장트리라고 할 수 있다. 따라서 T는 더 작은 신장트리로 구성된다고 할 수 있다. 따라서 처음 가설이 틀린 것이다.

그리디 선택: MST 문제가 그리디 선택 속성을 갖는다면 정점 v와 연결된 에지 중에서 최소 가중치 에지는 반드시 최소 신장 트리 T에 속해야 한다. 귀류법을 사용하여 이 가설을 증명할 수 있다.

1.정점 v에 연결되어 있는 에지 중에서 최소 가중치를 갖는 에지를 (u,v)라고 가정한다. 

2.만약 (u,v)가 T에 속하지 않는다면 T는 v와 연결되어 있는 다른 에지를 포함해야 한다. 이 에지를 (x,v)라고 한다. (u,v)가 최소 가중치 에지이기 때문에, (x,v)는 (u,v)의 가중치보다 커야 한다. 

3.T에서 (x,v)를 제거하고 (u,v)를 추가할 경우 전체 가중치가 더 작은 트리를 얻을 수 있다. 이는 T가 최소 신장 트리라는 가정에 위배된다. 따라서 그리디 선택 속성을 만족한다.

이 알고리즘을 구현하려면 그래프 에지 정보를 저장할 자료 구조가 필요하고, 새로운 에지를 추가할 때 사이클이 발생하는지를 판단하는 기능이 필요하다. 이 문제는 디스조인트-셋 자료 구조를 사용하여 해결할 수 있다.

# 2023.08.08

# copy_jpg (using c style file input-output)

C 언어의 함수인 fopen_s를 사용하여 jpg파일을 복사하는 코드이다.

# 2023.08.09

# Linux File-System upgrade version
이전에 공부했던 N-항 트리를 이용한 리눅스 파일 시스템에서 부모 노드의 주소를 저장하여 이전 노드로 디렉토리를 움직일 수 있다. 
또한 현재 노드가 소유한 모든 디렉토리를 보여주는 all기능도 추가했다.

# Graph Coloring

그래프 컬러링은 실생활의 다양한 문제에 적용할 수 있다. 택시 예약 스케줄 작성, 스도쿠 퍼즐 풀기, 시험 시간표 작성 등 그래프로 모델링한 후 컬러링 문제 형태로 해결할 수 있다. 그러나 그래프 컬러링에 필요한 최소 개수의 색상 수를 찾는 것은 NP-완전 문제로 알려져 있다. 다만 문제를 조금 변경함으로써 시간 복잡도를 크게 변경할 수 있다.

스도쿠 문제는 다음과 같이 해결할 수 있다. 

1.각각의 셀을 그래프 정점으로 표현한다.

2.같은 행, 같은 열, 3*3 블록 안에 있는 모든 정점끼리 에지를 연결한다.

3.생성된 그래프 G에 대해 그래프 컬러링을 수행하면 입력 스도쿠 퍼즐의 해답을 구할 수 있다.

그래프 컬러링의 평가는 얼마나 적은 수의 색상을 사용했는가에 의해 결정된다. 가능한 적은 수의 색상을 사용하는 최적의 그래프 컬러링 방법 찾기는 
NP-완전 문제이지만, 그리디 방식이 유용한 근사치를 제공하곤 한다. 예를 들어 컴파일러를 설계할 경우, 컴파일하는 프로그램의 변수에 CPU 레지스터를 할당하기 위해 그래프 컬러링이 사용된다. 몇몇 휴리스틱 방법과 함께 그리디 방식의 컬러링 알고리즘을 사용하면 “충분히 괜찮은” 솔루션을 얻을 수 있으며, 이러한 방식은 컴파일러의 빠른 동작이 필요한 상황에서 바람직하다.

# Normal_Tree (색다른 버전의 트리)

이전에 공부했던 Tree와 살짝 다른 구조를 가지고 있다.

# 2023.08.21

# BehaviorTree

언리얼 엔진의 BehaviorTree를 간단하게 구현한 예제이다. Selector, Sequence, Decorator, ActionNode 등이 있고 간단한 처리가 가능하다. 

N항 트리 구조를 사용했다.

# DungeonGenerator

N항 트리를 사용한 리눅스 파일 시스템 코드를 변형하여 TXT_RPG에 사용할 DungeonGenerator를 구성했다. 

# Welsh-Powell algorithm (웰시 포웰 알고리즘 - 그래프 컬러링)

앞서 살펴본 그래프 컬러링의 성능을 조금 향상시키는 방법이 있다. 차수가 높은 정점부터 차례대로 그래프 컬러링을 수행하는 것이다. 이를 웰시 포웰 알고리즘이라고 한다. 

1.모든 정점을 차수에 대한 내림차순으로 정렬하고 배열에 저장한다. 

2.정렬된 배열에서 색상이 지정되지 않은 첫 번째 정점을 선택하고, 이 정점과 연결된 모든 정점을 조사하여 아직 사용되지 않은 색상을 해당 정점에 지정한다. 이 색상을 C라고 지정한다. 

3.정렬된 배열에서 색상이 지정되지 않은 정점을 모두 찾고, 만약 이 정점의 이웃이 C 색상을 가지고 있지 않다면 해당 정점에 C를 부여한다.

4.배열에 색상이 지정되지 않은 정점이 남아 있다면 2단계로 이동한다. 남아 있는 정점이 없다면 종료한다. 이때까지 정점에 지정된 색상이 최종 결과다.

차수는 정점에서 연결된 선의 개수이다.

<구현 솔루션>

1.먼저 에지를 표현하는 Edge 구조체와 에지 리스트를 사용하여 그래프 구조를 표현하는 Graph클래스를 작성해야 한다. 

2.웰시 포웰 그래프 컬러링 알고리즘을 구현한 함수를 작성한다. 이 함수는 각 정점의 색상을 벡터로 반환하도록 한다. 이 벡터의 I번째 원소는 I번째에 해당하는 정점의 색상을 나타낸다. 

일반적인 그래프 컬러링 알고리즘보다 성능이 좋다. 이유는 정점의 차수를 고려하지 않고 차례대로 색깔을 검사하는 것 보다 차수가 큰 정점부터 색깔을 조사하는 것이 더 효율적이기
때문이다.

# BFS(Breadth_First_Search) 너비 우선 탐색

그래프에서 너비 우선 탐색은 시작 정점을 경계에 추가하는 것으로 시작한다. 경계는 이전에 방문했던 정점들에 의해 구성된다. 그리고 현재 경계에 인접한 정점을 반복적으로 탐색한다.

BFS는 모든 정점에 대해 자식 정점을 손자 정점보다 먼저 방문한다는 점이 중요한 특징이다. BFS를 구현할 경우, 보통 경게를 별도의 자료 구조를 만들어서 명시적으로 사용하지는 않는다. 대신 정점 ID를 큐에 저장하여 시작 정점과 가까운 정점을 멀리 있는 정점보다 먼저 방문할 수 있도록 구현한다.

BFS의 시간 복잡도는 O(V+E)이다. V는 정점의 개수이고, E는 에지의 개수이다.

# DFS(Depth_First_Search) 깊이 우선 탐색

너비 우선 탐색이 시작 정점에서 시작하여 점차 탐색 범위를 넓혀 나가는 방식이라면, 깊이 우선 탐색은 시작 정점에서 시작하여 특별 경로를 따라 가능한 멀리 있는 정점을 재귀적으로 먼저 방문하는 방식이다. 그리고 더 방문할 정점이 없어지면 다른 경로를 찾아 다시 멀어지는 방향으로 탐색을 반복한다. 이러한 그래프 탐색 방법을 백트래킹이라고 한다. DFS는 큐 대신 스택을 사용한다. 스택은 후입선출 속성을 가지고 있기 때문에 현재 정점과 인접한 정점들을 재귀적으로 이동하면서 방문할 때 사용하기에 적합한 자료 구조이다.

BFS와 DFS의 시간 복잡도는 모두 O(V+E)이다. 그러나 두 알고리즘에는 몇 가지 큰 차이가 있다. 다음은 BFS와 DFS의 두드러진 차이점과 적합한 사용 시나리오를 정리한 것이다. 

*BFS는 시작 정점에서 가까운 정점을 찾는 데 적합하고, DFS는 대체로 시작 정점에서 멀리 있는 정점을 찾을 때 적합하다.

*BFS에서 특정 정점을 방문할 경우, 시작 정점에서 해당 정점까지의 최단 거리 경로가 보장된다. 그러나 DFS는 최단 경로를 보장하지 않는다. 이러한 속성 때문에 단일-시작 또는 다중-시작 최단 경로 알고리즘이 BFS 알고리즘을 조금 변경하여 사용하고 있다.

*BFS는 현재 경계에 인접한 모든 정점을 방문하므로 BFS에 의해 생성된 검색 트리는 짧고 넓은 편이며, 많은 메모리를 필요로 한다. 반면에 DFS에 의해 생성된 검색 트리는 길고 좁은 편이며 상대적으로 적은 메모리를 필요로 한다.

# 2023.08.22

# Bipartite_Graph discrimination (이분 그래프 판별 코드)

이분 그래프는 정점을 두 개의 집합으로 나눌 수 있는 그래프이다. 이때 그래프의 모든 에지는 서로 다른 집합에 속한 정점끼리 연결되어야 한다. 이분 그래프는 실생활의 여러 문제를 모델링할 수 있다. 예를 들어 학생 목록과 수업 목록이 있을 때, 학생들이 어떤 수업을 수강하고 있는지를 이분 그래프로 표현할 수 있다. 즉, 학생 정점에서 수업 과목 정점으로 에지가 연결되어 있으면 해당 학생이 이 수업을 수강하고 있다는 의미이다. 학생에서 학생으로, 또는 수업에서 다른 수업으로 연결되는 에지는 있을 수 없다. 따라서 이분 그래프로 표현하기 적합하다.

특정 학생이 신청한 두 개의 수업이 같은 시간대에 중복되지 않도록 수강 계획을 만드는 데 사용할 수 있다. 예를 들어 유미가 수학과 영어 과목을 수강했다면 두 수업이 같은 시간대에 진행되면 안된다. 수업 시간표 작성 시 이러한 충돌을 최소화하는 작업은 그래프에서 최대 유량 문제를 풀어서 달성할 수 있다. 최대 유량 문제에 대해서는 몇 가지 표준 알고리즘이 알려져 있다. 포드-풀커슨 알고리즘, 디닉 알고리즘, 푸시-리레이블 알고리즘이 그 예이다. 그러나 이들 알고리즘은 꽤 복잡하여 지금은 다루지 않는다.

넷플릭스나 유튜브같은 대형 비디오 스트리밍 플랫폼에서 제공되는 영화 목록과 시청자 사이의 관계도 이분 그래프를 사용하여 모델링할 수 있다. 즉, 사용자가 특정 영화를 시청했다면 에지를 연결하는 방식으로 사용자의 시청 기록을 관리할 수 있다.

이분 그래프에 대해 흥미로운 사실은 최대 매칭 또는 최소 정점 커버 문제처럼 일반 그래프에서는 NP-완전인 문제들이 이분 그래프에서는 다항시간으로 풀 수 있다는 사실이다. 따라서 주어진 그래프가 이분인지 아닌지를 알아내는 것은 매우 중요하다. 

다음은 주어진 그래프가 이분 그래프인지 확인하는 c++프로그램의 아이디어이다. 이분 그래프를 판별하는 알고리즘은 DFS를 조금 변형하여 만들 수 있다.

1. 1번 정점부터 DFS를 시작한다고 가정한다. 그러므로 1번 정점을 스택에 추가한다.

2.만약 스택에 방문하지 않은 정점이 남아 있으면 스택에서 정점을 하나 꺼내고 이를 현재 정점으로 설정한다.

3.이전 정점에 할당된 색상이 ‘검은색’이면, 현재 정점에 ‘빨간색’을 할당한다. 반대로 이전 정점에 할당된 색상이 ‘빨간색’이면 현재 정점에 ‘검은색’을 할당한다.

4.현재 정점과 인접한 정점들 중에서 아직 방문하지 않은 정점들을 스택에 넣고, 현재 정점을 방문한 것으로 설정한다.

5.모든 정점에 색상이 지정될 때까지 2~4단계를 반복한다. 알고리즘 종료 시 모든 정점에 색상이 칠해져 있다면 이 그래프는 이분 그래프이다.

6.만약 탐색을 진행하다가 만나게 된 정점이 이미 방문한 정점이고, 이 정점의 색상이 현재 할당할 색상과 다른 색상이면, 알고리즘을 종료하고, 해당 그래프가 이분 그래프가 아니라고 판별한다.

즉 이분 그래프가 주어졌다면 두 집합을 번갈아가며 다른 색으로 모두 칠할 수 있기에 이분 그래프로 판별하고, 만약 같은 색상으로 할당된 인접한 정점을 만나면 이분 그래프가 아니라고 판별한다.

# Prim MST Algorithm (프림 최소 신장 트리)

MST 문제를 다시 정의해보면 “정점 집합 V와 가중치를 갖는 에지 집합 E로 구성된 그래프 G=<V,E>가 주어질 때 모든 정점을 연결하고 연결된 에지의 가중치 합이 최소인 트리 T를 구한다.”

크루스칼 알고리즘은 그래프의 모든 에지를 최소 힙에 추가하고, 사이클을 만들지 않는 최소 가중치의 에지를 이용하여 MST를 구성한다.

프림 알고리즘은 BFS의 동작 방식과 유사하다. 프림 알고리즘은 먼저 시작 정점을 이용하여 경계를 구성한다. 경계는 이전에 방문했던 정점들에 의해 구성되며, 현재 경계에 인접한 정점을 반복적으로 탐색한다. 이때 프림 알고리즘은 경계를 관통하는 에지 중에서 가장 가중치가 작은 에지를 선택하고, 이 에지에 연결된 정점을 방문한다. 

프림 알고리즘을 구현하려면 그래프의 각 정점에 경계로부터의 거리(distance) 정보를 기록해야 한다.

1.모든 정점의 거리 값을 무한대로 초기화한다. 시작 정점에서 자기 자신까지의 거리는 0이므로 시작 정점의 거리 값은 0으로 설정한다. 그리고 모든 거리 값을 최소 힙 H에 추가한다.

2.최소 힙 H로부터 정점을 하나 꺼낸다. 이 정점을 U라고 하면, 정점 U는 경계에서 가장 가까이 있는 정점이다. 이 정점을 포함하도록 경계를 새로 설정한다. 

3.U와 인접한 모든 정점 V에 대해 만약 V의 거리 값이(U,V)의 에지 가중치보다 크면 V의 거리 값을 (U,V)의 에지 가중치로 설정한다. 처음에는 거리 값이 모두 무한대이기 때문에 시작 정점의 인접 정점들의 거리 값이 가중치로 초기화된다. 이 과정을 정점 U에 안착(settle)했다고 한다. 

4.방문하지 않은 정점이 남아 있다면 2단계로 이동한다.

5.모든 정점에 대해 안착한 후 최종 MST가 생성된다.
프림 알고리즘(Prim's Algorithm)은 최소 비용 신장 트리(Minimum Spanning Tree)를 찾는 그리디 알고리즘 중 하나입니다. 최소 비용 신장 트리란 그래프 내의 모든 정점을 포함하면서 간선의 가중치 합이 최소인 트리를 말합니다. 이 알고리즘에서 거리 값이 사용되는 이유는 다음과 같습니다.

프림 알고리즘의 목적은 주어진 연결 그래프에서 최소 비용 신장 트리를 구성하는 것입니다. 알고리즘이 진행되면서 트리가 점진적으로 확장되며, 트리 내의 정점들과 트리 밖의 정점들 사이에 새로운 간선을 연결하는 방식으로 진행됩니다. 이때, 선택되지 않은 정점들 중에서 최소 비용의 간선을 선택하여 트리에 추가하는 것이 핵심적인 아이디어입니다.

거리 값이 사용되는 이유는 다음과 같다:

정점의 선택: 알고리즘은 현재 트리에 속한 정점과 트리에 속하지 않은 정점 간의 간선 중 가장 작은 가중치를 가진 간선을 선택하여 트리에 연결다. 이때, 간선의 가중치를 거리 값으로 볼 수 있다. 가중치가 작을수록 두 정점 간의 거리가 짧다고 볼 수 있다.

트리 내 간선의 갱신: 이미 트리에 속한 정점과 트리에 속하지 않은 정점을 연결하는 간선 중에서 더 작은 가중치를 가진 간선이 나타날 수 있다. 이 경우, 새로운 간선으로 갱신하여 더 작은 거리 값을 사용하게 된다.

그래프 내에서의 최소 거리: 프림 알고리즘은 선택되지 않은 정점들 중에서 최소 비용의 간선을 찾아 트리에 추가한다. 이를 통해 최소 비용 신장 트리가 생성되는데, 이는 그래프 내의 정점들 간의 최소 거리를 고려한 결과라고 볼 수 있다.

종합적으로, 프림 알고리즘에서 거리 값은 정점 간의 연결을 결정하고 최소 비용 신장 트리를 형성하는 데 사용되는 중요한 개념이다.

# 2023.08.23

# Dijkstra Algorithm (최소 비용 경로)

“주어진 그래프 G=<V,E>가 있다. 여기서 V는 정점의 집합이고, E는 에지의 집합이다. 각각의 에지는 가중치를 가지고 있다. 시작 정점과 목적 정점이 주어질 때, 시작 정점에서 목적 정점까지 이어지는 최소 비용 경로를 구하시오.”

다익스트라 알고리즘은 음수 가중치가 없는 그래프에서 동작하는 최단 경로 탐색 알고리즘으로 프림의 MST 알고리즘을 약간 변형한 형태이다. 다익스트라 알고리즘이 프림 알고리즘과 다른 두 가지 차이점은 다음과 같다.

*프림 알고리즘은 경계로부터 최소 거리를 정점의 거리 값으로 설정하지만, 다익스트라 알고리즘은 시작 정점으로부터 각 정점까지의 전체 거리를 사용한다. 

*다익스트라 알고리즘은 목적 정점이 나타나면 종료하지만 프림 알고리즘은 모든 정점을 방문해야 종료한다.

다익스트라 알고리즘의 동작은 다음과 같다.

1.모든 정점의 거리 값을 무한대로 초기화한다. 시작 정점에서 자기 자신까지의 거리는 0이므로 시작 정점의 거리 값은 0으로 설정한다. 그리고 모든 거리 값을 최소 힙 H에 추가한다.

2.최소 힙 H로부터 정점을 하나 꺼낸다. 이 정점을 U라고 하면, 정점 U는 시작 정점에서 가장 가까운 정점이다. 만약 U가 목적 정점이면 최단 경로를 찾은 것이므로 알고리즘을 종료한다.

3.U와 인접한 모든 정점 V에 대해 만약 V의 거리 값이 (U의 거리값+ (U,V)의 가중치)보다 크면 V까지 다다르는 더 짧은 경로를 찾은 것으로 볼 수 있다. 그러므로 V의 거리 값을 (U의 거리 값+(U,V)에지 가중치)값으로 설정한다. 이러한 과정을 정점 U에 안착했다고 한다.

4.방문하지 않은 정점이 남아 있다면 2단계로 이동한다. 

5.최소 힙 H로부터 꺼낸 정점이 목적 정점이면 알고리즘을 종료한다.

다익스트라 알고리즘을 피보나치 최소 힙을 사용하여 구현한 시간 복잡도는 
O(E+VlogV)이다.

# USA_NY_shortest_path (다익스트라 알고리즘을 이용한 뉴욕 도로망 최소 비용 거리)

다익스트라 알고리즘을 사용하여 뉴욕시 도로망에서 최단 거리 경로를 찾는 프로그램을 만들어 본다. 이번 실습 문제에서 사용할 도로망 그래프는 264,326개의 정점과 733,846개의 방향 에지로 구성되고, 에지 가중치는 두 정점 사이의 유클리디언 거리로 정의된다. 

# Bellman_Ford_Algorithm(벨만 포드 알고리즘)

음수 가중치가 있는 그래프를 다룰 때에는 벨만-포드 알고리즘을 사용할 수 있다. 이 방법은 그래프의 모든 에지에 대해 다익스트라의 그리디 선택 방법을 
(V-1)번 반복하여 점진적으로 최단 거리를 찾는다. 여기서 V는 정점의 개수를 나타낸다. 벨만-포드 알고리즘은 다익스트라 알고리즘보다 높은 점근적 시간 복잡도를 가지지만, 다익스트라 알고리즘이 잘못 해석할 수 있는 그래프에 대해서도 정확한 결과를 제공한다.

# Greedy_Robot using Bellman-Ford Algorithm

장애물 코스에서 효율적인 경로를 찾는 길 찾기 로봇을 개발하려고 한다. 테스트를 위해 체스판 같은 정사각형 격자 형태의 코스를 몇 개 만들었다. 로봇은 어떤 장애물이든 통과할 수 있지만, 이 경우 많은 전력을 소모하게 된다. 로봇은 격자의 좌측 상단에서 출발하고, 동서남북 네 방향으로 이동할 수 있다. 로봇이 목적지에 도착할 때 남아있는 에너지가 최대가 되도록 경로를 선택하는 알고리즘을 구현해야 한다.

이러한 탐색을 하려면 많은 에너지를 필요로 하기 때문에 코스 곳곳에 충전소를 설치하였고, 로봇은 여기서 스스로 충전할 수 있다. 그러나 이 로봇은 꽤나 욕심이 많아서 충전소를 재방문할 수 있는 경로가 있다면 몇 번이고 다시 방문하여 충전을 반복하게 되고, 결국에는 과충전되어 폭발할 수 있다. 이 때문에 로봇이 충전소에 재방문할 것인지를 예측하여 과충전 같은 문제를 미연에 방지해야 한다.

*입력

첫 번째 줄은 정수 하나가 있으며, 이를 N이라고 한다. N은 코스의 가로 및 세로 크기를 나타낸다. 

그 다음에 나타나는 (N^2-1)줄은 방향을 가리키는 directions 문자열과 전력 소모량을 나타내는 power 정수 값으로 구성된다. 각각의 줄은 격자 모양 코스의 맨 처음 해의 왼쪽부터 오른쪽 방향으로 나타나는 셀(격자)의 정보를 나타낸다. 예를 들어 3x3 크기의 격자 코스인 경우, [0,0]->[0,1]->[0,2]->[1,0]->
[1,1]->[1,2]->[2,0]->[2,1] 순서로 셀 정보가 나타난다. 맨 마지막 셀은 목적지 이므로 셀 이동 정보가 없다.

direction문자열은 {'N','S','E','W'} 네 문자 중에서 0~3개를 이용하여 구성된다. 이 문자열은 로봇이 특정 지점에서 방문할 수 있는 셀 방향을 나타낸다. 즉 'N‘은 북쪽, ’S'는 남쪽, ‘E'는 동쪽, ’W'는 서쪽을 의미한다. 예를 들어 directions 문자열이 "SW"이면 로봇이 남쪽 또는 서쪽으로 이동할 수 있다. power는 셀을 이동할 때 필요한 전력 소비량을 나타낸다. p가 양수이면 현재 셀에 충전소가 있음을 나타낸다.

*출력

로봇이 코스의 우측 하단 셀에 도달할 때 가질 수 있는 최대 전력량을 출력하되, 시작시 전력량을 기준으로 상대적인 전력량을 출력한다. 예를 들어 로봇이 코스를 시작시 전력량보다 10만큼 더 많은 상태로 빠져나올 수 있다면 10을 출력한다. 만약 시작 시 전력량보다 10만큼 적은 상태로 빠져나올 수 있다면
-10을 출력한다. 

만약 탐색중에 로봇이 폭발할 경우 “탐색 중단” 문자열을 출력한다.

*문제 해결 가이드라인

벨만-포드 알고리즘에서 음수 사이클을 감지하는 알고리즘 이상의 것은 필요하지 않다.

입력을 해석하여 그래프를 구성하는 기능이 필요하다.

반드시 2차원 격자 형태의 코스를 만들 필요는 없다.

벨만-포드 알고리즘은 다익스트라 알고리즘이 제대로 작동하지 않는 그래프에 대해서도 정확한 결과를 제공하기 때문에 더 광범위하게 사용할 수 있다. 그러나 주어진 그래프가 음수 에지 가중치를 가지고 있지 않다면 그리디 방식을 사용하는 다익스트라 알고리즘이 더욱 효율적이다.

V번 이상의 반복에서 거리 값이 업데이트되는 경우에는 음의 사이클이 존재한다고 볼 수 있다. 각 반복마다 시작 정점부터 각 정점까지의 최단 경로에 최소 한 개 이상의 에지가 포함될 수
있기 때문에(최종 최단 거리가 아직 구해지지 않은 경우) 최대 V-1개의 에지가 경로에 포함될 수 있다. 따라서 V번 이상의 반복이 필요한 경우라면 V개 이상의 에지가 포함된다는 말인데
정점 개수보다 에지 개수가 많을 수는 없다. 따라서 중복 방문(사이클)이다.

# Johnson's Algorithm (벨만 포드와 다익스트라의 합성)

다익스트라 알고리즘과 벨만-포드 알고리즘의 효율성을 활용함과 동시에 음수 가중치를 갖는 그래프에 대해서도 올바른 결과를 생성할 수 있다. 존슨 알고리즘은 상당히 새로운 접근 방법을 사용한다. 이 알고리즘은 음수 가중치에 대한 다익스트라 알고리즘의 한계를 극복하기 위해 전체 에지 가중치를 음수가 아닌 형태로 변환한다. 이러한 작업은 벨만-포드 알고리즘과 적절한 수학 논리를 결합하여 이루어진다. 

존슨 알고리즘의 첫 번째 단계는 그래프에 새로운 ‘더미(dummy)' 정점을 추가하는 것이다. 그리고 이 더미 정점과 나머지 모든 정점 사이에 가중치가 0인 에지를 연결한다. 이후 벨만-포드 알고리즘을 이용하여 더미 정점과 나머지 정점들 사이의 최단 경로를 찾고, 나중에 사용하기 위해 각 정점까지의 최단 거리를 기록한다.

더미 정점 추가에 대해 좀 더 알아본다. 더미 정점과 나머지 모든 정점 사이에 가중치가 0인 에지를 연결했기 때문에 모든 최단 거리 값은 0보다 클 수 없다. 또한 그래프의 모든 정점에 대한 연결을 통해 거리 값이 모든 가능한 순회 경로에서 일정한 관계를 유지할 수 있으며 이로 인해 에지 가중치와 최단 거리의 합 연산이 간단해질 수 있다. 즉, 이동 경로상의 연속한 정점에 대해서 거리 값 연산이 서로 상쇄되어, 결국 전체 합은 첫 번째 정점과 마지막 정점의 거리 값 차와 같다.

존슨 알고리즘은 가중치를 다음 수식을 통해서 변환한다.

w(uv) = w(uv) + d[s,u] - d[s,v]

# Random_Graph_Generator (using Johnson's Algorithm)

임의의 회사에서 기술 면접에 사용하는 그래프 문제는 모든 정점 사이의 최단 경로 거리를 찾는 문제이다. 이때 사용하는 그래프는 방향성과 가중치가 있는 에지로 구성된다. 프로그램에 의해 생성된 그래프는 다음 항목을 만족해야 한다. 

*방향 그래프이어야 하며, 에지 가중치는 양수 또는 음수로 표현된다. 

*두 정점 사이에는 하나의 에지만 있으며, 특정 정점에서 나온 에지가 자기 자신으로 연결되는 셀프 에지는 없어야 한다.

*모든 정점에는 들어오거나 나가는 에지가 적어도 하나는 있어야 한다.

*에지 가중치의 절댓값은 100보다 작아야 한다.

그래프 생성 프로그램은 다음을 입력으로 받는다.

seed: 난수 발생기의 시드 값
iteration: 생성할 그래프의 개수
V:정점 개수
E:에지 개수

이 프로그램은 std::rand() 함수를 이용하여 에지를 생성하되, 두 정점 사이에 두 개 이상의 에지를 생성하면 안된다.

그래프 생성 순서는 다음과 같다.

1.입력으로 seed,iteration,V,E)값을 받는다.

2.난수 발생기의 시드 값으로 seed를 설정한다.

3. 다음 작업을 반복한다.

*i=0으로 설정

-rand 함수를 세 번 호출하여 시작 정점 source, 목표 정점 destination, 에지 가중치 w를 설정하고 이를 이용하여 에지를 생성한다.

-rand()함수로 다시 한 번 난수를 발생시키고, 이 값이 3으로 나누어 떨어지면 에지 가중치를 음수로 변환.

*만약 시작 정점과 목표 정점 사이에 이미 에지가 존재하면 다시 에지를 생성한다.

-에지 리스트에 edge(source,destination,weight)를 추가하고, I를 증가시킨다.

-만약 E개의 에지를 생성한 후 에지가 하나도 없는 정점이 남아 있다면 이 그래프는 유효하지 않은 것으로 판단.

만약 생성된 그래프가 유효하면 이제 그래프의 모든 정점 사이의 최단 경로를 찾아야 한다. 그리고 그래프의 각 정점에서 평균 최단 거리를 구하고자 한다. 정점의 평균 최단 거리는 해당 정점에서 출발하는 최단 경로의 거리 합을 도달 가능한 정점 개수로 나눈 값이다. 그래프 하나의 평균 거리는 모든 정점의 평균 최단 거리에 대한 평균으로 정의한다.

또한 가장 많은 흥미로운 그래프를 생성하는 값의 구성도 알아내려고 한다. 여기서 흥미로운 그래프란 그래프의 평균 거리가 가장 큰 에지 가중치의 절반보다 작은 경우를 의미한다. 그러므로 유효한 그래프 개수와 흥미로운 그래프 개수의 비율을 계산해서 출력해야 한다. 음수 가중치 사이클이 있는 그래프는 유효한 그래프이지만 흥미로운 그래프에는 포함되지 않는다.

입력

네 개의 정수 (seed,iteration,V,E)로 이루어진 한 줄

출력

출력은 두 줄로 구성된다. 첫 번째 줄은 “유효하지 않은 그래프 개수:” 문자열과 함께 유효하지 않은 그래프 개수를 출력한다. 두 번째 줄은 “흥미로운 그래프 생성 비율: ”문자열과 함께 (흥미로운 그래프 개수*100/유효한 그래프 개수)값을 출력한다. 이 값은 소수점 세 번째 자리에서 반올림하여 출력한다.

*문제해결 가이드라인

std::rand() 함수가 모든 환경에서 항상 동일한 값을 생성하지는 않는다. 제시된 난수 발생 코드를 참고한다.

# 2023.08.28

# Kosaraju Algorithm (strongly connected component)

<강한 연결 요소>

그래프 분류 방법중 가장 널리 사용되는 것은 방향 그래프와 무방향 그래프로 나누는 것이다. 무방향 그래프는 에지가 양방향으로 이동 가능하다고 간주한다.

다양한 채널 구독자 간의 공통점에 대한 통계를 작성해야 한다고 가정한다. 특정 채널을 구독하는 사람들과 해당 채널 소유주의 구독 정보 사이의 패턴을 발견하는데 관심이 많으며 이를 통해 타깃 광고 서비스를 어떻게 관리해야 하는지에 대해 분석하려고 한다.

구독하고 있는 채널 관계를 에지로 표현하면, 같은 채널을 구독하는 대규모 사용자 그룹이 여럿 있다 하더라도 각각의 구독 정보가 너무 다양하기 때문에 사용자 그룹 사이의 유사점을 찾기가 힘들다. 

방향 그래프의 특성으로 이러한 복잡한 문제를 해결할 수 있다. 방향 그래프에서는 한쪽 방향으로만 이동이 가능하기 때문에 특정 정점에 도달할 수 있는지 여부는 탐색을 어느 정점에서 시작했는지에 따라 다르게 결정된다. 주어진 그래프를 여러 개의 구역으로 나누되 같은 구역 안의 정점끼리는 서로 이동 가능한 경로를 갖도록 나눌 경우, 각 구역은 해당 그래프의 강한 연결 요소를 나타낸다.

<방향 그래프와 무방향 그래프에서 연결성>

무방향 그래프에서 연결 요소란 모든 정점이 서로 연결되어 있는 부분 그래프 중에서 최대 크기 부분 그래프 집합을 의미한다. 즉 하나의 구성 요소에 있는 두 정점은 상호 접근이 가능하다. 모든 정점이 연결되어 있는 그래프의 경우, 어느 정점에서 출발하든 모든 정점에 도달할 수 있으므로 이러한 그래프는 단일 연결 요소로 구성되어 있다고 할 수 있다. 상대적으로 특정 정점에서 다른 정점으로 이동할 수 없는 경우, 이러한 그래프는 연결이 끊어졋다고 할 수 있다.

이와 달리 강한 연결성은 방향 그래프에만 적용되는 특징이다.

무방향 그래프에서는 연결 요소(정점들이 연결된 부분 그래프)들이 서로 독립적이고 각 연결 요소의 정점들에서 다른 연결 요소의 정점으로 이동할 수 없다. 

반면에 강한 연결 요소는 그래프 내에서 다른 부분 그래프와 완전히 단절되어 있을 필요는 없다. 부분 그래프 사이에 경로가 존재할 수 있다. 즉 연결 요소 A,B,C가 있을 때 A는 B,C로 모두 이동할 수 있는 반면 B는 C로만 이동할 수 있고, C는 다른 연결 요소로는 이동할 수 없다. 이런 식으로 방향 그래프의 연결 요소는 이러한 형태를 지닌다. 각 강한 연결 요소끼리는 양방향으로 연결될 수 없다는 것이 특징이다. 

<코사라주 알고리즘>

그래프에서 강한 연결 요소를 찾는 가장 쉽고 널리 사용되는 방법으로 코사라주 알고리즘이 있다. 코사라주 알고리즘은 DFS를 두 번 수행하는 행태로 동작한다. 처음에는 입력 그래프 자체에 DFS를 수행하고, 두 번째에는 입력 그래프를 전치하여 DFS를 수행한다. 코사라주 알고리즘에서는 BFS로 수행할 수도 있다. 

그래프의 전치는 원본 그래프에서 시작 정점과 목표 정점이 서로 뒤바뀐 형태로, 각각의 에지 방향이 반대가 된다. 즉, 원본 그래프에 A정점에서 B정점으로 향하는 에지가 있다고 하자, 전치된 그래프에서는 B정점에서 A정점으로 향하는 에지가 있다.

코사라주 알고리즘의 첫 번째는 모든 정점 중에서 아직 방문한 적이 없는 정점에 대해 차례대로 DFS 순회를 진행하는 것이다. 각 정점에 대해 DFS를 수행할 때에는 먼저 해당 정점에 대해 방문 기록을 저장하고, 이후 이 정점과 인접한 정점 중에서 아직 방문하지 않은 정점을 재귀적으로 탐색한다. 인접한 정점을 모두 탐색한 후에는 현재 정점을 스택에 추가한 후 DFS를 종료한다.

원본 그래프에 대해 DFS 순회가 끝나면 이번에는 같은 작업을 전치 그래프에 대해 수행한다. 앞서 구축한 스택에서 정점을 하나씩 꺼내고, 이 정점을 아직 방문하지 않았다면 이 정점을 시작으로 DFS를 수행한다. 이때 각각의 DFS에서 만나는 정점들이 강한 연결 요소를 구성한다. 

코사라주 알고리즘은 그래프가 인접 리스트로 표현되어 있을 경우, O(V+E)형태의 선형 점근적 시간 복잡도를 갖기 때문에 효율적이다. 코사라주 알고리즘에서 인접 행렬을 사용하는 것은 좋지 않다. 왜냐하면 그래프 순회에서 각 정점의 이웃을 찾기 위해 상당한 양의 반복문이 필요하기 때문이다.

위 수식을 사용하면 telescope 속성을 사용할 수 있어 최종 수식이 짧아진다. 또한 모든 에지의 가중치를 0 이상의 값으로 변경할 수 있다.

벨만-포드 알고리즘은 d[s,u] + w(u,v) >= d[s,v]를 만족하기 때문에 변환된 가중치는 음수가 될 수 없다. d[s,v]가 0이기 때문이다. 

즉 원래의 최단 경로 순서는 그대로 유지한 채, 음이 아닌 가중치로 구성된 그래프가 만들어진다. 이제 새로운 가중치를 갖는 그래프의 각 정점에서 다익스트라 알고리즘을 적용하여 모든 정점 쌍 사이의 최단 거리를 구할 수 있다.

# Maze Teleportation Game

여러 개의 방으로 구성된 미로 안에 여러 명의 플레이어가 무작위로 배치되는 게임을 설계한다고 가정한다. 각 방에는 미로의 다른 방으로 이동할 수 있는 한 개 이상의 순간이동 장치가 있다. 각각의 순간이동 장치는 고유한 정수 값이 매겨져 있어서 플레이어가 순간이동장치를 사용하면 해당 값이 플레이어 점수에 더해진다. 각각의 플레이어는 모든 방을 한 번 이상 방문할 때까지 교대로 이동하고, 각 라운드가 끝났을 때 점수가 가장 낮은 플레이어가 승자가 된다. 

매 번 게임이 시작될 때마다 새로운 미로를 자동으로 생성하는 시스템을 개발했다. 그런데 자동 생성된 미로 중 일부에서 플레이어의 점수를 무한히 낮출 수 있는 이동 경로가 존재한다는 점을 알게 되었다. 또한 몇몇 플레이어는 시작 지점에 따라 점수 계산에 불이익을 받을 수 있다는 점도 발견했다. 무엇보다 플레이어가 미로의 특정 방을 방문할 수 없는 형태로 순간이동장치가 배치되기도 한다. 

생성된 미로가 유효하고 모든 플레이어에 공평한 형태인지를 확인하는 테스트 기능을 구현해야 한다. 먼저 미로에 플레이어 점수를 무한히 낮아지게 만들 수 있는 경로가 존재하는지 확인해야 한다. 만약 이러한 경로가 있다면 “유효하지 않은 미로”문자열을 출력해야 한다. 만약 방에 순간이동장치가 없는 경우에는 “고립된 방” 문자열을 출력한다.

또한 플레이어가 미로의 특정 부분에 갇히는 것을 방지하기 위해 미로의 다른 위치로 이동할 수 없는 방 그룹 정보도 출력해야 한다.

일단 실제 구현에서는 모든 방이 아니라 각각의 방에서 다른 방으로 이동할 때의 최저 점수를 구하도록 구현되어 있다.


[입력] 

*미로 안의 방 개수

*미로 안의 순간이동장치 개수

*시작 방, 목표 방, 각 순간이동장치에 지정할 점수

[출력]

프로그램은 먼저 플레이어의 점수를 무한대로 낮출 수 있는 경로가 존재하는지를 확인해야 한다. 이러한 경로가 존재하면, “유효하지 않은 미로” 문자열을 출력한다.

만약 미로가 유효하다면 각각의 방에서 다른 나머지 방으로 이동할 때 얻을 수 있는 최저 점수를 차례로 출력한다. 만약 특정 방에 순간이동장치가 없다면 “고립된 방” 문자열을 출력한다. 마지막으로 플레이어가 완전히 갇혀있게 되는 방 그룹, 즉 미로의 다른 부분으로 이동할 수 없는 방들의 번호를 출력한다.

[문제 해결 가이드라인]

관련 없는 정보로 인해 주의가 흐트러지지 않도록 한다. 실제적으로 무엇을 수행해야 하는지 자문한다.

미로에 점수를 무한히 낮출 수 있는 경로가 있는지를 판단하는 것은 다음과 같이 해석할 수 있다. 즉 미로를 가중 그래프로 표현하고, 여기에 음수 가중치사이클이 있는지를 판단하면 된다.

고립될 수 있는 경우가 어떤 경우인지를 생각해보라. 즉 강한 연결 요소에서 가장 마지막 연결 요소일 것이다. 따라서 강한 연결 요소가 있는지를 확인하면 될 것이다.

# 2023.08.29

# 적절한 방법을 선택하자. - Graph Algorithm

인접 리스트와 인접 행렬, 클래스와 단순 행렬, 벨만-포드 알고리즘과 존슨 알고리즘, BFS와 DFS등의 선택에서 어떤 것을 사용할 것인가는 데이터 특성과 우리의 선택에 달려 있다. 예를 들어 그래프의 모든 정점 사이의 최단 거리를 알아내고자 한다면 존슨 알고리즘을 사용하는 것이 가장 좋은 선택일 것이다.

그래프 이론과 구현 방법에 대한 이해를 높이는 방법은 다음과 같다.

1. 새로운 알고리즘을 구현할 때 복사&붙여넣기 사용을 지양해야 한다. 만약 내가 알고리즘 동작의 기본 원리를 이해하지 못하고 있다면 알고리즘을 잘못 사용할 가능성이 매우 높다. 만약 알고리즘이 원하는 방식으로 작동하더라도 그래프 구현은 주어진 상황에 매우 의존적이라는 점을 기억해야 한다. 알고리즘을 맹목적으로 사용하면 입력 매개변수가 조금 달라졌을 때 프로그램을 확장하기 어려울 수 있다.

2. 실전에서 새로운 기능을 추가할 때 추상적이거나 상황을 고려하지 않은 구현은 주의해야 한다. 검증 가능한 이론적인 데이터를 이용하여 알고리즘을 구현한 후, 실제 사용할 데이터에 맞게끔 소스코드를 수정해야 한다. 새로 배운 알고리즘을 어떻게 적용할 수 있을지를 자주 상상해보면 실제 업무에서 언제 어떻게 사용할 수 있는지에 대한 감을 얻을 수 있을 것이다.

*그래프를 구현하기에 앞서 다음 사항을 숙지해야 한다.

1. 기본 목적 및 해당 목적 달성을 위해 필요한 기능(즉, 그래프 표현 방법, 함수 입출력 형식,기능 확장성 등)

2. 주어진 문제와 연관된 정보를 나타내는데 필요한 가장 기본적인 구성 요소

이러한 핵심 사항들을 숙지하지 못한다면 실제 솔루션에 전혀 도움이 되지 않는 불필요한 데이터와 함수로 가득 찬, 복잡하고 지나치게 장황한 코드가 만들어질 수 있다. 실제 코드를 작성하기에 앞서 꼭 필요한 그래프 구성 요소를 계획하면 상당한 혼란과 지루한 리팩토링을 줄일 수 있다.

궁극적으로 그래프 프로그래밍에 대한 포괄적인 이해는 단순히 여러 알고리즘을 배우는 것 이상의 노력이 필요하다. 자명하지 않은 그래프 문제에 대해 웹 검색을 해보면 매우 복잡한 연구 분석, 다양한 접근 방식의 비교 평가, 합리적인 구현이 아직 발견되지 않은 추측에 의한 솔루션 등을 아주 많이 발견할 수 있을 것이다. 늘 그렇듯이 지속적인 연습은 프로그래밍 기술을 습득하는 가장 좋은 방법이다.

# 동적 계획법(Dynamic Programming)

동적 계획법(Dynamic programming)은 분할 정복 패러다임을 확장한 것으로, 특정 분류의 문제에 사용된다. 이전에 다루었던 그리디 알고리즘은 특정 상황에서는 상당히 효과적이지만, 그렇지 않은 경우에는 최적의 결과를 도출하지 못할 수 있다. 예를 들어 음수 가중치를 가진 그래프에서는 벨만-포드 알고리즘은 최적의 해를 찾을 수 있지만, 다익스트라 알고리즘은 그렇지 않다는 점을 바로 앞 장에서 설명했다. 앞서 언급한 기법으로 해결할 수 없는 문제 중에서 재귀적으로 표현할 수 있는 문제는 아마도 동적 계획법이 가장 적합할 수 있다.

다음은 동적 계획법이 자주 사용되는 경우이다.

*조합(특정 조건을 만족하는 시퀀스의 조합 또는 순열의 개수 구하기)

*문자열과 시퀀스(편집 거리, 최장 공통 부분 시퀀스, 최장 증가 부분 시퀀스 등)

*그래프(최단 경로 문제)

*머신 러닝(음성/얼굴 인식)


동적 계획법의 원리에 대해서 알아본다.

다음은 피보나치 수열이다

0 1 1 2 3 5 ...

이를 수식으로 표현하면 다음과 같다.

F(0)=0

F(1)=1

F(n)=F(n-1)+F(n-2) //이 수식은 수열의 재귀 관계를 표현한다.

이 수식으로부터 피보나치 수열이 재귀적인 관계를 가지고 있음을 알 수 있다. 이 수열의 처음 두 원소 F(0),F(1)은 기저 조건이라고 부르며, 이는 더 이상 재귀가 없어도 해를 구할 수 있는 지점을 나타낸다.


F5는 F4+F3과 같고,

	여기서 F4는 F3+F2와 같고

		여기서 F3은 F2+F1과 같고

			여기서 F2는 F1+F0과 같고,

				여기서 F1=1이고 F0=0이다.

			그리고 F1=1이다.

		그리고 F2는 F1+F0과 같고

			여기서 F1=1이고 F0=0이다.

	그리고 F3은 F2+F1과 같고

		여기서 F2는 F1+F0과 같고

			여기서 F1=1이고 F0=0이다.

		그리고 F1=1이다.

이와 같은 방식을 하향식 해법(top-down solution)이라고 부른다. 왜냐하면 전체 해결 방법을 트리 형태로 구성한 재귀 트리의 맨 꼭대기에서 시작하여 기저 조건에 닿을 때까지 아래쪽 가지로 이동하기 때문이다. 이러한 연산을 C++재귀 함수로 구현하면 다음과 같다.

int Fibonacci(int n)

{
	if(n<2)

		return n;

	return Fibonacci(n-1)+Fibonacci(n-2);

}

트리를 자세히 보면 해답을 찾기 위해 여러 개의 부분 문제 또는 중간 문제를 풀어야 한다는 점을 알 수 있고, 또한 이러한 부분 문제는 한 번 이상 나타난다는 점을 발견할 수 있다. 예를 들어 F2는 F4와 F3을 구하는 과정에서 중복해서 나타난다. 왜냐하면 F4=F3+F2이고 F3=F2+F1이기 때문이다. 그러므로 피보나치 수열은 중복되는 부분 문제라는 특성을 가지고 있다고 말할 수 있다. 이는 일반적인 분할 정복 문제와 동적 계획법 문제를 구분하는 특성 중 하나이다. 분할 정복 문제에서는 전체 문제가 독립적인 부분 문제로 나뉘는 경향이 있지만, 동적 계획법의 경우에는 같은 부분 문제가 반복적으로 나타난다.

또한 여러 부분 문제가 서로 완전히 동일하다는 것을 알 수 있다. 예를 들어 F2를 구해야 할 경우, 이것이 F4또는 F3 중에서 어느 것을 구하기 위해 필요한지에 관계없이 같은 방식의 연산을 수행하면 된다. 이를 최적 부분 구조라고 부르며, 이것이 동적 계획법 문제를 정의하는 두 번째 특성이다. 전체 문제에 대한 최적해야 부분 문제의 최적해의 조합으로 표현할 수 있을 최적 부분 구조를 갖는다고 표현한다.
어떤 문제를 동적 계획법으로 해결하려면 이 두 가지 속성을 만족해야 한다. 중복되는 부분 문제 특성으로 인해 문제의 복잡도가 입력이 증가함에 따라 기하급수적으로 증가하는 경향이 있지만 최적 부분 구조 속성을 활용하면 복잡도를 크게 줄일 수 있다. 동적 계획법에서는 본질적으로 반복 계산을 피하기 위해 이전에 해결한 부분 문제의 해답을 캐시에 저장하는 방식을 사용한다.


<메모이제이션: 하향식 접근 방법>

메모이제이션(memoization)은 메모를 한다는 의미이다. 메모이제이션을 사용하여 최적 부분 구조 특성을 갖는 피보나치 수열에 대해 하향식 해법을 재구성할 수 있다. 프로그램 로직은 이전과 같지만, 각 단계에서 부분 문제의 해답을 찾으면 이를 배열 구조의 캐시에 저장한다. 배열의 인덱스는 현재의 n값을 사용할 것이며 여기서 n은 피보나치 수열 문제 풀이 단계의 매개변수 집합 또는 상태(state)를 나타낸다. 함수 F(n)이 호출될 때마다 먼저 F(n)의 상태가 이미 캐시에 저장되어 있는지를 확인한다. 만약 캐시에 값이 저장되어 있다면 단순히 이 값을 반환한다.

const int UNKNOWN=-1;

const int MAX_SIZE = 100;

vector<int> memo(MAX_SIZE,UNKNOWN);

int Fibonacci(int n)

{

	if(n<2)

		return n;

	if(memo[n] != UNKNOWN)

		return memo[n];


	int result = Fibonacci(n-1)+Fibonacci(n-2);

	memo[n] = result;

	return result;

}

이러한 방식을 통해 상당히 많은 중복 작업을 제거할 수 있다. 이처럼 하향식 방식에서 부분 문제의 해를 캐시에 넣어 사용하는 기술을 메모이제이션이라고 하며, 이 방법은 모든 동적 계획법 문제에 적용할 수 있다. 이때 다음 조건을 만족한다고 가정한다.

1. 고유한 특성은 유지하면서 서로 다른 상태의 유사성을 활용하는 캐시 사용 방식을 고안할 수 있다.

2. 사용 가능한 스택 공간을 초과하기 전에 필요한 모든 부분 문제의 해답을 누적할 수 있다.

첫 번째 항목은 부분 문제 해법을 캐시에 인덱싱하여 저장하는 방법이 유효하고 유용해야 한다는 점을 의미한다. 캐시 사용 방법이 유효하려면 같은 의미의 부분 문제 해법을 정확하게 일치시켜 저장해야 한다. 또한 캐시 사용 방법이 유용하려면 너무 특정 상태에만 치우치게 동작하면 안된다. 예를 들어 모든 부분 문제가 같은 위치의 캐시를 참조한다면 

if(memo[KEY] != UNKNOWN)와 같은 조건에 걸리는 경우가 거의 없을 것이다.

두 번째 항목은 스택 오버플로우가 발생할 가능성에 관한 것으로, 이는 너무 많은 재귀 함수 호출을 필요로 하는 하향식 접근 방법에서 근본적으로 발생하는 문제이다. 스택 오버플로는 프로그램이 정해진 호출 스택 메모리보다 많은 메모리를 사용할 때 발생한다. 주어진 문제가 재귀 호출을너무 많이 필요로 할 경우 메모이제이션을 사용하지 못할 수도 있다. 늘 그렇듯이, 어떤 방법을 사용할 것인지를 선택하기에 앞서 주어진 문제의 잠재적인 복잡도를 평가하는 작업은 꽤 유용하다,

동적 계획법 문제에서 메모이제이션은 상당히 괜찮은 최적화 방법이다. 그러나 많은 경우 더 나은 방법을 선택할 수 있으며, 이 방법에 대해서는 다음 절에서 자세히 살펴본다.

동적 계획법의 핵심은 메모이제이션과 반대 방식의 접근 방법인 타뷸레이션
(tabulation)이라고 할 수 있다. 사실 동적 계획법이라는 용어가 메모이제이션과 타뷸레이션 두 가지 모두에 적용되긴 하지만, 일반적으로는 타불레이션을 더 많이 의식하여 사용한다.
타뷸레이션은 기저 조건 해답부터 시작하여 모든 부분 문제에 대한 해답을 표에 저장한 후 재사용하는 방식이다. 타뷸레이션 방식은 각각의 부분 문제 상태를 재귀적으로 표현할 수 있어야 하기 때문에 메모이제이션보다 개념적으로 어렵게 느껴진다.

타불레이션을 이용하여 피보나치 수열을 계산하는 함수는 다음과 같이 작성할 수 있다.

int Fibonacci(int n)

{	

	vector<int> DP(n+1,0);

	DP[1]=1;

	for(int i=2;i<=n;++i)

	{

		DP[i]=DP[i-1]+DP[i-2];

	}

	return DP[n];
}

피보나치 예제는 상태가 1차원으로 표현되고 n이 1보다 큰 경우에 항상 F(n)=
F(n-1)+F(n-2) 수식 하나를 사용하기 때문에 매우 간단하다. 그러나 많은 동적 계획법 문제가 상태를 다차원으로 표현해야 하고, 상태 전환 방식을 여러 개의 조건식으로 표현해야 할 경우도 있다. 이러한 경우 현재 상태를 제대로 표현하려면 문제에 대한 포괄적인 이해와 상당한 창의력이 필요하다.

타뷸레이션 방식의 장점은 꽤 많다. 타뷸레이션 방식은 메모리 사용량 관점에서 매우 효율적이며, 또한 가능한 모든 상태를 기록하는 룩업 레이블을 생성할 수 있다. 그러므로 주어진 문제에 대해 임의의 여러 상태를 참조해야 하는 경우에는 타뷸레이션이 최선의 방법이 될 수 있다.

보통 메모이제이션으로 해결할 수 있는 모든 문제는 타뷸레이션 방식으로도 재구성할 수 있으며, 그 반대도 가능하다. 주어진 문제를 메모이제이션 방식으로 풀이해보면 이 문제를 타뷸레이션 방식으로 해결하기 위해 어떻게 접근해야 하는지에 대한 감을 얻을 수 있다.

# SubsetSub_Problem_BruteForce (Dynamic Programming)

디지털 금전등록기 로직을 구현해야 한다고 가정한다. 계산원이 고객에게 잔돈을 거슬러주어야 할 때, 현재 금전등록기에 남아 있는 동전을 조합하여 필요한 거스름돈을 만들 수 있는지를 화면에 표시하려고 한다. 예를 들어 제품이 7500원이고 고객이 10000원을 지불했다면 현재 금전 등록기에서 정확하게 
2500원의 거스름돈을 꺼낼 수 있는지를 표시해야 한다. 현재 금전 등록기에 1000원 지폐 다섯장과 500원 동전 네 개, 100원 동전 15개가 있다고 가정할 경우, 거스름돈 2500원을 만들기 위해 다음과 같은 방식을 조합할 수 있다.

1000원 지폐 2장, 500원 한 개

1000원 지폐 2장, 100원 5개 

1000원 지폐 1장, 500원 3개

...

위의 나열된 경우의 수를 살펴보면, 다소 직관적으로 모든 화폐 조합을 시도해보는 방법으로 해결할 수 있다. 그러나 만약 필요한 잔돈이 73270원이고, 현재 금전 등록기에 50000원권, 10000원권, 1000원권, 500원, 100원, 50원, 10원 동전들이 전체 100개가 들어있다면 어떨까? 이러한 경우 모든 경우의 수를 조합하는 것은 너무 복잡해지고, 실제로 구현하는 것이 비현실적이라고 생각할 수 있다. 이것이 바로 부분집합의 합 문제이다. 부분집합의 합 문제를 한 문장으로 표현하면 다음과 같다.

“음수가 아닌 정수로 이루어진 집합 S와 임의의 정수 x가 주어질 때, S의 부분집합 중에서 그 원소의 합이 x와 같은 부분집합이 존재하는가?”

예를 하나 들어본다.

S={13,79,45,29}

x=42 -> true(13+29)

x= 25 -> false

집합 S={13,79,45,29} 형태로 주어질 경우 총 16개의 부분집합을 추출할 수 있다.

전체 부분집합의 개수는 2^n임을 알 수 있다. n이 늘어날수록 전체 부분집합을 검토하는 것은 비효율적이다.


<동적 계획법 필요 조건 분석하기>

부분집합의 합과 같은 문제에 직면하게 되면 먼저 이 문제를 동적 계획법으로 해결할 수 있는지를 확인해야 한다. 일반적으로 주어진 문제가 다음 속성을 가지고 있다면 동적 계획법으로 해결할 수 있다.

*중복되는 부분 문제: 일반적인 분할 정복 기법과 마찬가지로, 최종해(final solution)은 여러 부분 문제 조합으로 표현될 수 있어야 한다. 그러나 분할 정복과는 달리 특정 부분 문제가 여러 번 발생할 수 있다.

*최적 부분 문제 구조: 주어진 문제에 대한 최적해(optimal solution)는 부분 문제의 최적해로부터 생성될 수 있다.

크기가 n인 부분집합은 크기가 n-1인 부분집합에 새로운 원소 하나를 추가하여 만들 수 있다. 이는 새로운 부분집합을 구성하기 위한 최적의 방법이며 크기가 0보다 큰 모든 부분집합에 적용된다. 그러므로 부분집합의 합 문제는 최적 부분 구조를 갖는다고 볼 수 있다. 또한 서로 다른 부분집합이 더 작은 크기의 부분집합으로부터 생성될 수 있다. 예를 들어 {13 79 45}와 {13 79 29}는 모두 {13 79}가 중복되어 들어가므로 중복되는 부분 문제 속성도 가지고 있다.

<기저 조건과 상태 정의하기>

주어진 문제가 동적 계획법 문제임을 확인했다면 이제 이 문제에서 상태(state)를 구성하기 위해 필요한 것이 무엇인지 파악해야 한다. 즉, 각 부분 문제를 다른 부분 문제와 다르다고 판단할 수 있는 기준을 찾아야 한다. 처음부터 동적 계획법 문제의 상태를 제대로 정의하여 해를 구할 수 있다면 매우 바람집하겠지만, 주어진 문제의 최적해가 어떻게 구성되는지에 대한 명확한 이해 없이 상태를 정의하는 것은 쉽지 않다. 그러므로 문제의 해를 구하기 위한 가장 직관적인 방법부터 구현해보는 것도 좋다. 여기서는 비교적 구현하기 쉬운 두 가지 방법으로 부분집합의 합 문제를 해결해보면서 이 문제의 기저 조건과 상태에 대해 알아본다.

동적 계획법에 대해 알아보면서 전수 조사, 백트래킹, 메모이제이션, 타뷸레이션이라는 네 가지 접근 방법을 고려할 것이다. 이들 네 가지 접근 방법은 모든 동적 계획법 문제에서 정확한 결과를 제공하지만, 처음 세 방법은 입력 크기가 증가함에 따라 그 한계가 금방 드러나게 된다. 그럼에도 이들 방법을 차례대로 구현해보면 다양한 동적 계획법 문제를 해결할 때 큰 효과를 볼 수 있다.

<전수 조사>

전수 조사 방법은 분명히 비효율적이지만 현재 다루고 있는 문제를 제대로 이해하는 데 도움이 된다. 전수 조사 방법을 구현하는 것은 동적 계획법의 문제의 해를 구하는 과정에서 필수적인 단계가 될 수 있으며, 여기에는 다음과 같은 이유가 있다.

*단순성

효율성에 대한 고려 없이 단순한 방법으로 문제의 해를 구하는 작업은 주어진 문제의 근본적인 속성을 이해하는 데 도움이 된다. 주어진 문제에 대한 충분한 이해 없이 복잡한 방법으로 접근하는 것보다 최대한 단순하게 접근하는 것이 문제의 본질을 이해하기 쉽다.

*정답 비교를 위한 수단: 몇몇 복잡한 동적 계획법 문제의 경우, 주어진 문제를 충분히 이해하게 되면 상당히 많은 재설계가 필요할 수 있다. 이 때문에 우리가 동적 계획법으로 구한 해답과 비교할 수 있는 정답을 가지고 있을 필요가 있다.

*부분 문제를 시각화하는 능력

전수 조사 방법은 가능한 모든 방법을 생성한 후, 문제의 조건을 만족하는 해를 찾는 방법이다. 이러한 방법은 올바른 해답이 형성되는 방식을 시각화하는 수단을 제공할 수 있다. 이를 이용하여 다른 풀이 방법에서 사용할 수 있는 필수 패턴을 찾을 수 있다.

# SubsetSum_Backtracking (for Optimization)

전수조사 방법에서는 검사하는 부분집합의 합이 target보다 큰 경우에도 계속해서 검사를 진행했다. 유효하지 않은 모든 경우를 제거하는 백트래킹 기법을 사용할 수 있다.

백트래킹 방법을 구현하려면 주어진 문제의 기저 조건과 재귀적 표현을 결정해야 하며, 이러한작업은 이후 동적 계획법을 적용할 때 도움이 된다. 이 장의 앞부분에서 정의했듯이, 기저 조건이란 재귀 함수에서 추가적인 재귀 호출을 진행하지 않고 해를 구할 수 있는 경우를 의미한다. 이해를 돕기 위해 팩토리얼을 계산하는 경우를 예로 들어보자.

정수 n의 팩토리얼은 n*(n-1)*(n-2)*... 수식으로 계산된다. 팩토리얼을 계산하는 C++함수를 다음과 같이 작성할 수 있다.

int Factorial(int n)

{

	//기저 조건 - 재귀 호출 멈추기

	if( n == 1 )

	{

		return 1;
	}
	
	//기저 조건을 만날 때까지 재귀 호출 수행

	return n*Factorial(n-1);

}

팩토리얼 계산에서는 n==1인 경우에 재귀 호출을 하지 않고 함수가 반환되므로 n==1인 경우가 기저 조건이 된다.

부분집합 합 문제에서는 다음과 같이 기저 조건을 정의할 수 있다.

-만약 현재 부분집합의 합이 target보다 크면 : False
-만약 집합의 끝에 도달한 경우 : False

기저 조건을 만들었으니 이제 상태 변화 방법을 정의해야 한다. 


*상태 변화 방식은 다음과 같다.

-집합 set의 I번째 원소 set[i]와 부분집합 ss에 대해:

	만약 ss의 합에 set[i]를 더한 결과가 target보다 작거나 같으면:

	(1) ss에 set[i]를 추가

	(2) I를 증가
	
	다음 상태 - > ( i=i+1, ss = ss U set[i]) (U는 합집합 기호)


	모든 경우에 대해:

	(1) ss에 set[i]를 추가하지 않음

	(2) I를 증가

	다음 상태 -> ( I = I + 1 ,ss = ss )


이제 다음 물음에 대해 생각을 해본다.

	*현재 상태를 표현하기 위해 필요한 최소 데이터는 얼마인가?

	*불필요한 정보를 제거하기 위해 앞서 설명한 논리를 어떻게 재구성할 것인가?

부분집합의 합 문제를 다시 생각해본다. 이 문제는 주어진 집합의 부분집합 중에서 그 합이 정수 target과 같은 부분집합이 있는지를 판별하는 것이 목적이다. 문제 정의에 의하면 풀이 과정에서 실제 부분집합이 어떻게 구성되는지는 나타낼 필요가 없고, 단지 그 부분집합의 합만 검사하면 된다. 그러므로 상태 변화 의사 코드를 다음과 같이 간결하게 변경할 수 있다.

-집합 set의 I번째 원소 set[i]와 부분집합의 합 sum에 대해:

	만약 sum에 set[i]를 더한 결과가 target보다 작거나 같으면:

	(1) sum에 set[i]를 더함

	(2) I증가

	다음 상태 -> ( I = I+1 , sum = sum + set[i] )


	모든 경우에 대해:

	(1) sum에 set[i]를 더하지 않음

	(2) I증가

	다음 상태 ->( I = I+1 , sum = sum)

이러한 의사 코드를 사용하면 중간 단계 상태를 sum과 I 두 개의 정수로 표현할 수 있다. 최악의 경우 2^n개로 구성될 수 있는 부분집합 배열을 사용하지 않아도 된다. 또한 문제 접근 방식을 target값부터 시작해서 매 단계마다 set[i] 값을 빼는 형태로 전환하면 target값을 가지고 다니지 않게끔 만들 수도 있다. 마지막 최적화 방법으로 함수 호출 전에 집합을 정렬함으로써 target값보다 값이 커지는 경우를 만나면 나머지 집합 원소는 고려하지 않도록 만들 수도 있다.

BruteForce 방식으로 풀었던 SubsetSum 문제를 Backtracking 방법을 사용한 최적화 방식(불필요한 재귀를 줄인)으로 작성해본다. 

결과를 보면 BruteForce 방법보다 BackTracking 방법이 1000배 빠른 것을 확인할 수 있다.

# 2023.08.30

# Memoization (dynamic-programming)

백트래킹 방법이 전수 조사 방법보다는 훨씬 우수하지만 여전히 최선의 방법은 아니다. 부분집합의 합 목표치가 매우 큰 경우에 대해 생각해보겠다. 만약 목표치가 입력 집합의 모든 원소 합보다 같거나 크다면 사전에 입력 집합의 원소 합을 미리 계산하여 목표치가 유효한 범위 안에 있는지를 검사할 수 있을 것이다. 그러나 목표 합이 입력 집합의 모든 원소 합보다 미세하게 작다면 알고리즘 전체를 실행하여 모든 가능한 경우를 확인해야 한다.

이러한 차이를 확인하기 위해 barcktracking 방식의 코드에 입력을 6799로 설정하고 실행해보라, 이 값은 입력 집합 set의 모든 원소 합보다 정확히 1 작은 값이다. 아마 이전 결과보다 350배 더 느린 시간이 기록될 것이다. 다행히 메모이제이션이라는 하향식 방법을 사용하기에 필요한 모든 정보를 이미 가지고 있다. 더군다나 메모이제이션을 구현하기 위해 기존에 사용했던 방법을 수정할 필요도 없다.

*캐시 사용하기

메모이제이션을 사용하는 데 있어 가장 중요한 것은 캐시를 어떻게 사용할 것인지를 결정하는 것이다. 메모이제이션을 위한 캐시는 다양한 방식으로 정의할 수 있지만, 일반적인 방법은 다음과 같다.

*정수 인덱스를 사용하는 일반 배열

*프로그래밍 언어에서 제공하는 해시 기능을 사용하여 상태를 문자열로 표현한 해시 테이블 또는 해시 맵

*자체적으로 생성한 해시 함수를 이용하여 상태를 표현한 해시 테이블 또는 해시 맵

-어떤 것을 사용할 지에 대한 일반적인 지침은 다음과 같다.

*정수 인덱스를 사용하는 배열과 벡터는 일반적으로 맵보다 빠르다. 맵은 이미 캐시가 존재하는지를 확인하기 위해 주어진 키에 해당하는 위치를 찾는 작업이 필요하기 때문이다.

*상태를 정수로 표현할 수 있다고 하더라도 그 값이 너무 크게 나타날 경우, 실제 필요한 메모리보다 훨씬 큰 크기의 배열이 필요할 수 있다. 따라서 비합리적이다. 이러한 경우에는 맵이 나을 수 있다.

*std::unordered_map과 같은 해시 테이블은 일반적인 맵/딕셔너리 구조보다 빠르게 키를 찾고 검색할 수 있다.(그러나 여전히 배열보다는 느리다)

*std::map은 키로 사용할 수 있는 자료형 측면에서 std::unorderd_map보다 훨씬 더 자유도가 높다. std::unordered_map은 기술적으로 동일한 기능을 제공할 수 있지만, 기본적으로 키로 사용할 수 없는 자료형에 대해서는 프로그래머가 직접 해싱 함수를 만들어야 한다.

map은 키를 기준으로 정렬하기 때문에 사용자 정의 자료형에 대해서 해싱 함수를 따로 정의하지 않아도 되지만, unorderd_map은 사용자 정의 자료형을 사용하려면 해싱 함수를 따로 정의해야 하기 때문에 map이 자료형에 대해서는 자유도가 높다.


*캐시 사용 방법은 다음을 만족해야 한다.

-유효성: 캐시의 키 값은 서로 다른 상태에 대해 충돌이 발생하지 않도록 표현해야 한다. 동일한 키 값에 대해 충돌이 발생하지 않아야 한다.

-유용성: 캐시 사용 방식이 너무 독특해서 캐시에 저장된 값을 참조하는 경우가 아예 발생하지 않는다면 아무 의미가 없다.

부분집합의 합 문제에서 부분집합의 합을 상태로 사용할 경우, 특정 sum값을 갖는 상태에서 목표치를 찾지 못한다는 것이 같은 sum값을 갖는 다른 상태에서도 목표치를 찾지 못한다고 잘못 인식할 수 있다. 즉 

if( memo[sum] != UNKNOWN )
	
	return memo[sum];

형태의 코드를 사용하면 문제가 발생할 수 있다. 이는 같은 sum값에 도달할 수 있는 여러 가지 경우의 수가 있다는 사실을 고려하지 못해서 발생하는 잘못된 캐시 사용방법이다. 다음 예를 살펴본다.

{ 1 5 6 2 3 9 }

부분집합 { 1 5 }의 합 = 6

부분집합 { 6 }의 합 = 6

부분집합 { 1 2 3 }의 합 = 6

위 예에서 부분집합의 합 목표치가 8이라고 가정한다. 만약 세 번째 경우를 먼저 만나게 되면 memo[6]은 false로 반환할 것이다. 

그러나 첫 번째와 두 번째 경우에 대해서는 원소 2를 추가하여 8을 만들 수 있으므로 false를 반환하는 것이 잘못되었음을 알 수 있다.

즉 sum이 6이 되는 경우의 수가 많은데 그 중에서 2를 추가하여 8을 만들 수 있는 경우가 있음에도 불구하고 { 1 2 3 }을 먼저 만났을 때 sum이 6인 상태에서는 8을 만들 수 없다고 판단할 수 있다는 것이다.

잘못된 메모이제이션 방법의 또 다른 예는 부분집합 구성에 사용된 원소의 모든 인덱스를 키로 사용하는 것이다. 이 경우는 모든 상태가 고유한 형태의 키로 구성되고, 그 결과 같은 부분 문제에 의해 캐시가 참조되는 경우가 발생하지 않기 때문이다.

만약 구상한 캐시 사용 방식의 유효성을 알고 싶다면, 카운터 변수를 하나 만들고 캐시 참조가 발생할 때마다 카운터 변수 값을 하나씩 증가시킨다. 만약 해답이 구해진 상태에서도 값이 0이거나 또는 고려해야 할 상태 개수에 비해 매우 낮은 값이라면 우리의 캐시 사용 방법은 개선이 필요하다고 결론지을 수 있다.

연습 문제의 실행 결과를 앞선 2가지 방법과 비교하면 극적으로 최적화되어 있음을 알 수 있다.

# 2023.08.31

# SubsetSum using Tabulation (dynamic programming)

지금까지 부분집합의 합 문제를 해결하기 위한 세 가지 알고리즘을 구현해보았으며, 각각의 방법은 이전 방법에 비해 성능이 크게 개선되었다. 그러나 주어진 집합에 대해 가능한 모든 부분집합의 합 목록을 얻고 싶다고 가정한다. 공집합부터 전체 집합의 총합까지, 각각의 부분집합의 합을 구하기 위해 알고리즘을 반복적으로 실행해야 한다. 이러한 경우에는 타뷸레이션이 효과적이다.

이와 같은 문제에서 표를 사용하는 형태의 해법을 구현한다는 것을 개념화하기는 쉽지 않다. 주어진 문제를 재귀식으로 표현하는 것은 다차원 상태 표현과 분기 구조에는 잘 부합하지만, 표 형식 해법은 복잡한 계층을 for/while 문법에 의한 단순한 반복문 구조로 표현해야 한다.

메모이제이션과 마찬가지로 기저 조건과 상태를 정의한 후 해야 할 첫 번째 작업은 서로 다른 상태에 대한 해법을 어떻게 저장할 것인지를 결정하는 것이다. 일반적으로 타뷸레이션 방법에서는 간단한 배열 또는 벡터를 사용한다. 앞에서 이미 피보나치 수열 계산을 위해 정수형 벡터 DP를 선언하여 사용한 적이 있다.


vector<int> DP(n+1,0);

...

DP[i] = DP[i-1]+DP[i-2];


앞에서 팩토리얼을 재귀적으로 계산하는 방법에 대해 설명했다, 상향식 접근 방법으로 표를 채우면서 문제를 푸는 과정을 다음 수식으로 표현할 수 있다.

factorial[n] = factorial[n-1]*n;

팩토리얼 계산은 1차원으로 구성되고, 조건문도 필요 없는 매우 단순한 예이다. 각각의 상태는 처음부터 끝까지 일관된 수식으로 표현된다. 피보나치 수열 또는 팩토리얼 문제와 부분집합의 합 문제의 근본적인 차이점은 상태 표현을 위해 필요한 최소 차원 수가 다르다는 점이다. 즉, 부분집합의 합 문제는 현재까지의 부분집합의 합과 현재 처리하고 있는 집합의 인덱스가 필요하다. 부분집합 문제에 대해 좀 더 깊이 있게 생각해본다.

*크기가 k인 부분집합은 크기가 k-1인 부분집합에 새로운 원소를 추가하여 구성할 수 있다.

*인덱스 i에서 같은 부분집합의 합 x를 갖는 어떤 부분집합의 조합이든 최종적으로 같은 결과를 형성한다.


입력 집합 = {2 5 6 3 7 20}

목표치 = 28

	   i:    0    1    2      3     4        5
부분집합의 합: 2{2} 2{2} 8{2 6} 8{2 6} 8{2 6} 28{2 6 20}  - TRUE

부분집합의 함: -   5{5}  5{5}   8{5 3}  8{5 3}  28{5 3 20}  - TRUE


위에서 8을 어떤 과정으로든 도달한 후에는 무조건 TRUE로 종결된다. 부분집합의 합 문제가 최적 부분 구조 속성을 만족하기 때문이다.  8을 만족하는 집합은 마지막 20을 더하여 28을 만들 수 있기 때문에 최적 부분 구조 속성인 8만 만들면 된다. 8이 부분 문제인 것이다.


이러한 사실을 염두에 두고, 이제 하향식 접근 방식을 뒤집어 상향식 접근 방법을 개발해본다. 


<하향식 로직>

1. 부분집합의 합 목표치와 집합의 첫 번째 인덱스에서 시작

2. 입력 집합 전체에 대해 반복:

 - 만약 부분집합의 합이 0이 되면 결과는 TRUE이다.

 - 만약 입력 집합의 끝에 도달했다면 결과는 FALSE이다.

 - 그렇지 않으면 부분집합의 합에서 현재 인덱스의 집합을 빼거나 또는 그대로 유지한다.

3. 만약 부분집합의 합 x와 인덱스 i로 표현되는 상태 S에서 목표치를 찾을 수 있다면, 상태 S로 이어질 수 있는 모든 이전 상태에서도 목표치를 찾을 수 있다.


<상향식 로직>

1. 부분집합의 합과 인덱스를 0으로 설정하여 시작

2. 입력 집합 전체에 대해 반복: 

- 만약 인덱스가 0에서 i 사이일 때 x와 같은 부분집합의 합을 찾을 수 있다면, 인덱스가 0에서 I+1 사이에서도 x와 같은 부분집합의 합을 찾을 수 있다.

 - 만약 입력 인덱스가 0에서 i사이일 때 x와 같은 부분집합의 합을 찾을 수 있다면, 인덱스 0에서 i+1 사이에서 x+set[i]와 같은 부분집합의 합을 찾을 수 있다.


표를 채우는 방식과 관련해서, 하향식 접근 방법은 다음 규칙을 따른다.

상태 S1에서 부분집합의 합이 x와 같고 인덱스 i 인 경우, 다음 중 하나라도 성립하면 memo(i,x) = true이다.

- 부분집합의 합이 x-set[i]이고, 인덱스가 I+1인 상태 S2에서 목표치가 발견될 경우

- 부분집합의 합이 x이고 인덱스가 I+1인 상태 S3에서 목표치가 발견될 경우

그렇지 않으면 memo(i,x)=false이다.


이러한 로직을 상향식으로 바꾸면 다음과 같다.


만약 부분집합의 합이 x이고 인덱스가 I인 경우 다음중 하나라도 성립하면 
DP(i,x) = true이다.

-x가 set[i]보다 작고 DP(i-1,x) = true

인덱스 I에서 x<set[i]이고, 이전 인덱스에서의 결과가 true일 때

-x가 set[i]보다 크거나 같고, DP(i-1,sum) = true 또는 DP(i-1,sum-set[i]) = true)

인덱스 I에서 x>=set[i]이고 이전 인덱스에서 결과에서 둘 중 하나가 true일 때 

그렇지 않으면 DP(i,x) = false

즉, 인덱스가 0에서 I사이일 때 부분집합의 합이 x가 될 수 있다면 인덱스 0에서 I+1일 때에는 부분집합의 합이 x또는 x+set[i]가 될 수 있다. 

# Travel_Itinerary (dynamic programming)

고객의 여행 일정 작성을 도와주는 여행사 웹 프로그램을 만들려고 한다. 이 프로그램은 사용자의 여행 경로를 설계하는 데 초점을 맞추고 있다. 즉, 사용자가 방문하고 싶은 여러 여행지를 선택하면 최종 목적지로 이동하는 동안 통과해야 하는 도시 목록을 보여준다.

여행사는 주요 도시의 특정 운송 회사와 계약을 맺고 있으며, 각 운송 회사는 최대 운행 거리에 대한 제한을 가지고 있다. 비행기나 기차는 여러 도시를 운행할 수 있지만, 버스나 택시는 처음 출발 위치에서 가까운 한두 도시만 이동할 수 있다. 프로그램의 경우 가능한 여행 도시 목록을 생성하면 각 여행지에서 이동 가능한 최대 도시 개수가 함께 나타나고, 이를 활용하여 고객은 여행 경로를 구상할 수 있다.

최근 이 프로그램에 가능한 여행 경로를 필터링해서 보여주는 기능이 필요하다고 생각했다. 많은 인기 관광지는 몇몇 마을별로 구분되어 있기 때문이다. 이를 위해 출발지에서 목적지로 도달하는 모든 경로의 수를 미리 계산하여 너무 많은 경우의 수가 나타나는 것을 막으려고 한다.

이 프로그램은 이미 출발지와 목적지 사이의 주요 도시 목록을 생성하는 기능을 가지고 있다. 그리고 다음 정보를 미리 알 수 있다. 

N: 출발지부터 목적지 사이에 있는 도시의 수

distance: 각 도시에서 이동할 수 있는 최대 도시 개수를 나타내는 정수 배열


*입력

입력의 첫 번째 줄에는 출발지와 목적지 사이의 도시 개수를 나타내는 N이 적혀 있다. 두 번째 줄에는 빈칸으로 구분된 N개의 정수 d가 나열되어 있으며, 각각의 d는 i 번째 도시에서 출발하여 이동할 수 있는 최대 거리를 나타낸다.

*출력

이 프로그램은 0번 도시에서 시작하여 N번 도시에 도달하는 여행 경로 가짓수를 나타내는 정수를 하나 출력한다. N이 증가함에 따라 이 출력값이 너무 커질 수 있으므로 실제 출력은 여행 경로 가짓수를 1000000007로 나눈 나머지를 출력한다.

*추가 점수

앞서 제시한 문제를 합리적인 시간 내에 결과를 출력하는 프로그램을 만들었다면 이제 N이 10000000인 경우에 대해서도 알고리즘의 효율성 테스트를 해볼 수 있을 것이다. 여기에 모든 거리 값을 출력할 수는 없으므로 다음 소스 코드를 사용하여 거리 값 배열을 생성하여 테스트를 진행한다.

vector<int> Generate(int n)

{

	vector<int> distance(n);

	LL val = 1;

	for(int I=0;i<n;++i)

	{
		val = (val * 1103515245 + 12345) / 65536;

		val %=32768;


		distance[i] = (( val % 10000) % (n-i)) + 1;
	
	}

	return distance;

}

이 함수로 생성한 테스트 케이스에 대해 318948158을 출력하면 정상이다. 프로그램을 최적화된 알고리즘으로 구현했다면 1초 이내에 답을 출력해야 한다.


문제 해결 가이드라인

	*최적의 방법은 O(n) 시간 내에 실행되며 정확히 n번 반복해야 한다.

	*처음부터 동적 계획법으로 문제를 풀기 어렵다면 이 장에서 설명한 	문제를 풀어봐라. 즉, 전수 조사 방법부터 시작해서 점진적으로 풀이 	방법을 최적화해야 한다.

	*이 문제의 상태 구성 방법은 피보나치 수열에서 나왔던 재귀 관계식	을 참고해라.
