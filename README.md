# Algorithm_Datastructure

# 2023.08.02

# Map_Reduce using STL (STL을 이용)

맵은 컨테이너 C를 입력으로 받아, 컨테이너의 모든 원소에 함수 f(x)를 적용하는 것이다. 예를 들어 f(x)=x^2함수를 사용할 경우에 대한 맵 연산을 다음에 나타낸다.
1 2 3 4 5 6 7
->1 4 9 16 25 36 49

리듀스는 컨테이너 C의 모든 원소 x에 함수 f(acc,x)를 적용하여 하나의 값으로 축약하는 연산이다. 예를 들어 f(acc,x)=acc+x 함수를 사용할 경우에 대한 리듀스 연산의 예를 다음에 나타낸다. 
1 2 3 4 5 6 7
->28

c++ 표준 라이브러리는 맵과 리듀스 연산을 std::transform()과
std::accumulate함수로 제공한다. c++17에서는 std::reduce()도 제공한다.
accumulate()는 기본적으로 누적 연산을 수행하기 때문에 리듀스 연산의 제한된 형태라고 볼 수 있다. c++17을 지원하는 최신 컴파일러에서는 더 일반적이며 병렬 처리도 지원하는 reduce()를 사용할 수 있다.

# Map_Reduce_PrimeNumber

맵 리듀스 모델을 사용하여 프로그램을 작성하려면 원하는 연산을 맵과 리듀스 두 단계로 표현할 수 있어야 한다. 맵(또는 파티션) 단계에서는 입력을 중간 단계의 <키,값>쌍으로 표현하고, 리듀스 단계에서는 중간 단계의 <키,값>쌍을 원하는 방식으로 결합하여 최종 결과를 생성한다.
하둡은 맵과 리듀스 연산을 확장성 있고 분산 처리가 가능하게 만듦으로써 컴퓨터 클러스터에서 동작할 수 있고 연산 시간을 크게 단축시킬 수 있다.

해당 코드는 양의 정수 N이 있을 때 1에서 N사이의 소수를 찾으려고 한다. 맵 리듀스 프로그래밍 모델과 멀티 스레드를 사용하여 이 문제를 해결한다.

# PPL (병렬 처리 라이브러리)

병렬 처리 라이브러리에서 제공하는 함수들과 STL 함수의 맵 작업의 속도를 비교하는 MS 레퍼런스의 코드이다. 
여러 프로세스를 처리하는 병렬 처리 방식을 사용하는 parallel_for_each함수가 더 빠른 것을 확인할 수 있다.

병렬 처리는 대규모의 데이터를 처리할 때 유용하게 사용되는 개념이다.

# Student_grade 

학생들의 정보를 저장하고 평균과 총점, 정보를 출력할 수 있는 클래스를 구현했다.

# 2023.08.03

# Greedy Algorithm (shortest -job-first-scheduling)

은행 창구에 줄을 서서 순서를 기다리는 사람들이 있다. 하필이면 은행이 바쁜 날이라서 하나의 창구에서만 업무를 보고 있고, 대기열에 N명의 사람들이 기다리고 있다. 이들은 서로 다른 용무로 방문했기 때문에 일 처리에 필요한 시간은 사람들마다 다르다. 대기열에 기다리고 있던 모든 사람이 매우 합리적이어서 평균 대기 시간이 최소화될 수 있도록 대기 순서를 다시 정하는 것에 동의했다. 그래서 이제 대기 순서를 어ᄄᅠᇂ게 바꿔야 하는지를 결정해야 한다.

일 처리 시간 		8 1 2 4 9 2 3 5
기다려야 하는 시간  0 8 9 11 15 24 26 29
평균 대기 시간 15.25

평균 대기 시간을 최소화하는 것이 목표이기 때문에 가능한 많은 사람의 대기 시간을 줄일 수 있는 방법을 찾아야 한다. 모든 사람의 대기 시간을 줄이려면 일 처리가 가장 빨리 끝나는 사람을 맨 앞에 세워야 한다. 이러한 방식을 반복하면 다음과 같이 재정렬할 수 있다.

일 처리 시간1 2 2 3 4 5 8 9 기다려야 하는 시간
0 1 3 5 8 12 17 25
평균 대기 시간 8.875

# Fractional_kanpsack_problem (분할 가능 배낭 문제)

0-1 배낭 문제라고도 부르는 일반 배낭 문제는 NP-완전 문제로 알려져 있어서 다항 시간 솔루션을 사용할 수 없다. 그러나 0-1배낭 문제를 조금 변경한 분할 가능 배낭 문제는 그리디 방식으로 해결할 수 있다. 이 두 가지 문제를 살펴보면서 문제 정의의 작은 차이가 문제 해결 방법에 큰 변화를 가져올 수 있다는 것을 알 수 있다.

# 
<0-1배낭 문제>

물건들의 집합 O={O1,O2,O3...,On)이 있고, 여기서 I번째 물건 Oi의 무게는 Wi이고 가격은 Vi이다. 그리고 최대 무게를 T까지 견딜 수 있는 가방이 하나 주어진다. 이제 물건들을 가방에 담아야 하는데, 가방에 넣은 물건들의 가격 합이 최대가 되도록 물건을 선택하려 한다. 단, 물건들의 무게 합이 T를 넘지 않아야 한다.

배낭 문제는 NP-완전 문제로 알려져 있고, 이 문제에 대한 다항 시간 솔루션은 알려져 있지 않다. 결과적으로 모든 가능한 조합을 조사하여 무게가 T를 넘지 않는 가장 높은 가격을 찾아내야 한다. 
#
<분할 가능 배낭 문제>

이번에는 앞서 설명한 일반 배낭 문제를 조금 바꿔본다. 즉, 주어진 물건을 원하는 형태로 얼마든지 분할할 수 있고, 각 물건의 일부분만을 배낭에 담을 수 있다고 가정한다. 실생활의 예를 들면, 상인이 기름,곡물,밀가루와 같은 품목을 다룬다고 생각하면 된다. 이 경우 각 품목을 원하는 양만큼 덜어내서 배낭에 담을 수 있다.

# interval_scheduling_solution(작업 스케줄링 문제)

각각의 작업은 ID로 구분되고, 특정 시간 시작 시간과 종료 시간 사이에만 수행할 수 있다. 정해진 시간 안에 최대한 많은 수의 작업을 완료하는 것이 목표이다. 이 경우 어떤 작업을, 어떤 순서로 수행해야 할까? 특정 시점에 오직 하나의 작업만 수행할 수 있다.

1.각각의 작업은 고유한 ID, 시작 시간, 종료 시간을 가진다. 이러한 작업을 표현할 구조체를 생성한다.

2.N개의 작업을 포함하는 std::list를 생성한다. 각 작업은 1부터 N까지의 고유한 ID를 가진다. 시작 시간과 종료 시간은 임의의 정수로 설정한다.

3.다음과 같은 방식으로 스케줄링 함수를 작성한다.


  a.종료 시간을 기준으로 전체 작업 리스트를 정렬한다.

  b.그리디 방식으로 가장 빠른 종료 시간을 갖는 작업을 선택한다.

  c.현재 선택된 작업과 시간이 겹치는 작업은 모두 제거한다. 즉, 현재 작업 종료 시간보다 먼저 시작하는 작업은 제거한다.

  d.리스트에 작업이 남아 있다면 b로 이동한다. 그렇지 않으면 선택된 작업들로 구성된 벡터를 반환한다.

# MST (Minimum Spanning Tree)

모든 문제에 그리디 방식을 적용할 수 있는 것은 아니다. 최적 부분 구조와 그리디 선택이라는 두 가지 속성을 모두 갖는 문제만 그리디 접근 방식으로 최적의 솔루션을 구할 수 있다.

*최적 부분 구조: 주어진 문제 p에 대한 최적의 솔루션이 p의 부분 문제들의 최적의 솔루션으로 구성될 경우, 문제 p가 최적의 부분 구조를 갖는다고 말한다.

*그리디 선택: 주어진 문제 P에 대한 지역적 최적 솔루션을 반복적으로 선택하여 전체 최적 솔루션을 구할 수 있는 경우, 문제 p가 그리디 선택 속성을 갖는다고 말한다.

최적 부분 구조와 그리디 선택 속성에 대해 이해하기 위해, 크루스칼 최소 신장 트리 알고리즘에 대해 알아본다.

최소 신장 트리는 다음과 같이 정의할 수 있다. “정점(vertex)의 집합 V와 가중치를 갖는 에지(Edge)의 집합E로 구성된 그래프 G=<V,E>가 주어질 때, 모든 정점을 연결하고 연결된 에지의 가중치 합이 최소인 트리 T를 구하시오.”

실생활에서 찾아볼 수 있는 MST 문제의 예로 상수도관 네트워크 또는 도로 네트워크 설계가 있다. 상수도관 네트워크 설계의 경우, 모든 사람에게 수돗물이 전달되어야 하고 전체 상수도관의 길이는 최소가 되는 것이 좋다. 도로 네트워크를 설계할 때는 모든 필요한 지점에 도로가 연결되어야 하고 도로의 전체 길이는 최소가 되는 것을 목표로 한다. 

최소 신장 트리T를 구하는 방법은 다음과 같다.

1.그래프 G의 모든 에지를 최소 힙 H에 추가한다.

2.H로부터 에지 e를 하나 꺼낸다. 당연히 e는 모든 에지 중에서 가장 가중치가 작은 에지이다.

3.e의 양 끝 정점이 이미 T에 있을 경우, e로 인해 T에서 사이클이 발생할 수 있다. 그러므로 이런 경우에는 e를 버리고 2단계로 이동한다.

4.최소 신장 트리 T에 e를 추가하고, 2단계로 이동한다.

이 알고리즘은 2단계부터 4단계까지를 반복하면서 가장 작은 가중치의 에지를 찾고, 이 에지에 의해 사이클이 발생하지 않으면 해당 에지와 양 끝 정점을 최종 솔루션에 추가한다. 이렇게 선택된 에지와 정점은 최소 신장 트리를 구성한다. 이 알고리즘은 매 반복마다 최소 에지 가중치를 선택하기 때문에 그리디 방식이라고 할 수 있다. 이 알고리즘을 크루스칼 최소 신장 트리 알고리즘이라고 한다.

최적 부분 구조: 귀류법을 사용하여 최적 부분 구조 속성을 증명해본다. 이를 위해 MST 문제가 최적 부분 구조 속성을 가지지 않는다고 가정한다. 즉, 최소 신장 트리가 더 작은 최소 신장 트리의 집합으로 구성되지 않는다고 가정한다.

1. 그래프 G의 정점으로 구성된 최소 신장 트리 T가 있다고 가정한다. T에서 에지 e를 하나 선택하여 제거한다. e를 제거하면 T가 더 작은 트리인 T1과 T2로 나눠진다.

2.MST 문제가 최적 부분 구조 속성을 갖지 않는다고 가정했으므로 T1보다 작은 가중치를 갖는 신장 트리 T1'이 존재해야 한다. 이 신장 트리 T1'과 T2를 에지 e로 연결한 새로운 신장 트리를 T'이라고 한다.

3. T'의 가중치가 T의 가중치보다 작으므로 처음에 T가 최소 신장 트리라고 가정했던 사실이 틀리게 된다.

정리하면 최소 신장 트리 T의 부분 구조인 T'의 가중치가 더 작으므로 T'도 신장트리라고 할 수 있다. 따라서 T는 더 작은 신장트리로 구성된다고 할 수 있다. 따라서 처음 가설이 틀린 것이다.

그리디 선택: MST 문제가 그리디 선택 속성을 갖는다면 정점 v와 연결된 에지 중에서 최소 가중치 에지는 반드시 최소 신장 트리 T에 속해야 한다. 귀류법을 사용하여 이 가설을 증명할 수 있다.

1.정점 v에 연결되어 있는 에지 중에서 최소 가중치를 갖는 에지를 (u,v)라고 가정한다. 

2.만약 (u,v)가 T에 속하지 않는다면 T는 v와 연결되어 있는 다른 에지를 포함해야 한다. 이 에지를 (x,v)라고 한다. (u,v)가 최소 가중치 에지이기 때문에, (x,v)는 (u,v)의 가중치보다 커야 한다. 

3.T에서 (x,v)를 제거하고 (u,v)를 추가할 경우 전체 가중치가 더 작은 트리를 얻을 수 있다. 이는 T가 최소 신장 트리라는 가정에 위배된다. 따라서 그리디 선택 속성을 만족한다.

이 알고리즘을 구현하려면 그래프 에지 정보를 저장할 자료 구조가 필요하고, 새로운 에지를 추가할 때 사이클이 발생하는지를 판단하는 기능이 필요하다. 이 문제는 디스조인트-셋 자료 구조를 사용하여 해결할 수 있다.

# 2023.08.08

# copy_jpg (using c style file input-output)

C 언어의 함수인 fopen_s를 사용하여 jpg파일을 복사하는 코드이다.

# 2023.08.09

# Linux File-System upgrade version
이전에 공부했던 N-항 트리를 이용한 리눅스 파일 시스템에서 부모 노드의 주소를 저장하여 이전 노드로 디렉토리를 움직일 수 있다. 
또한 현재 노드가 소유한 모든 디렉토리를 보여주는 all기능도 추가했다.

# Graph Coloring

그래프 컬러링은 실생활의 다양한 문제에 적용할 수 있다. 택시 예약 스케줄 작성, 스도쿠 퍼즐 풀기, 시험 시간표 작성 등 그래프로 모델링한 후 컬러링 문제 형태로 해결할 수 있다. 그러나 그래프 컬러링에 필요한 최소 개수의 색상 수를 찾는 것은 NP-완전 문제로 알려져 있다. 다만 문제를 조금 변경함으로써 시간 복잡도를 크게 변경할 수 있다.

스도쿠 문제는 다음과 같이 해결할 수 있다. 

1.각각의 셀을 그래프 정점으로 표현한다.

2.같은 행, 같은 열, 3*3 블록 안에 있는 모든 정점끼리 에지를 연결한다.

3.생성된 그래프 G에 대해 그래프 컬러링을 수행하면 입력 스도쿠 퍼즐의 해답을 구할 수 있다.

그래프 컬러링의 평가는 얼마나 적은 수의 색상을 사용했는가에 의해 결정된다. 가능한 적은 수의 색상을 사용하는 최적의 그래프 컬러링 방법 찾기는 
NP-완전 문제이지만, 그리디 방식이 유용한 근사치를 제공하곤 한다. 예를 들어 컴파일러를 설계할 경우, 컴파일하는 프로그램의 변수에 CPU 레지스터를 할당하기 위해 그래프 컬러링이 사용된다. 몇몇 휴리스틱 방법과 함께 그리디 방식의 컬러링 알고리즘을 사용하면 “충분히 괜찮은” 솔루션을 얻을 수 있으며, 이러한 방식은 컴파일러의 빠른 동작이 필요한 상황에서 바람직하다.

# Normal_Tree (색다른 버전의 트리)

이전에 공부했던 Tree와 살짝 다른 구조를 가지고 있다.

# BehaviorTree

언리얼 엔진의 BehaviorTree를 간단하게 구현한 예제이다. Selector, Sequence, Decorator, ActionNode 등이 있고 간단한 처리가 가능하다. 

N항 트리 구조를 사용했다.

# DungeonGenerator

N항 트리를 사용한 리눅스 파일 시스템 코드를 변형하여 TXT_RPG에 사용할 DungeonGenerator를 구성했다. 

# Welsh-Powell algorithm (웰시 포웰 알고리즘 - 그래프 컬러링)

앞서 살펴본 그래프 컬러링의 성능을 조금 향상시키는 방법이 있다. 차수가 높은 정점부터 차례대로 그래프 컬러링을 수행하는 것이다. 이를 웰시 포웰 알고리즘이라고 한다. 

1.모든 정점을 차수에 대한 내림차순으로 정렬하고 배열에 저장한다. 

2.정렬된 배열에서 색상이 지정되지 않은 첫 번째 정점을 선택하고, 이 정점과 연결된 모든 정점을 조사하여 아직 사용되지 않은 색상을 해당 정점에 지정한다. 이 색상을 C라고 지정한다. 

3.정렬된 배열에서 색상이 지정되지 않은 정점을 모두 찾고, 만약 이 정점의 이웃이 C 색상을 가지고 있지 않다면 해당 정점에 C를 부여한다.

4.배열에 색상이 지정되지 않은 정점이 남아 있다면 2단계로 이동한다. 남아 있는 정점이 없다면 종료한다. 이때까지 정점에 지정된 색상이 최종 결과다.

차수는 정점에서 연결된 선의 개수이다.

<구현 솔루션>

1.먼저 에지를 표현하는 Edge 구조체와 에지 리스트를 사용하여 그래프 구조를 표현하는 Graph클래스를 작성해야 한다. 

2.웰시 포웰 그래프 컬러링 알고리즘을 구현한 함수를 작성한다. 이 함수는 각 정점의 색상을 벡터로 반환하도록 한다. 이 벡터의 I번째 원소는 I번째에 해당하는 정점의 색상을 나타낸다. 
