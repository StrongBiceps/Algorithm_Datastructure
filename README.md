# Algorithm_Datastructure

# 2023.08.02

# Map_Reduce using STL (STL을 이용)

맵은 컨테이너 C를 입력으로 받아, 컨테이너의 모든 원소에 함수 f(x)를 적용하는 것이다. 예를 들어 f(x)=x^2함수를 사용할 경우에 대한 맵 연산을 다음에 나타낸다.
1 2 3 4 5 6 7
->1 4 9 16 25 36 49

리듀스는 컨테이너 C의 모든 원소 x에 함수 f(acc,x)를 적용하여 하나의 값으로 축약하는 연산이다. 예를 들어 f(acc,x)=acc+x 함수를 사용할 경우에 대한 리듀스 연산의 예를 다음에 나타낸다. 
1 2 3 4 5 6 7
->28

c++ 표준 라이브러리는 맵과 리듀스 연산을 std::transform()과
std::accumulate함수로 제공한다. c++17에서는 std::reduce()도 제공한다.
accumulate()는 기본적으로 누적 연산을 수행하기 때문에 리듀스 연산의 제한된 형태라고 볼 수 있다. c++17을 지원하는 최신 컴파일러에서는 더 일반적이며 병렬 처리도 지원하는 reduce()를 사용할 수 있다.

# Map_Reduce_PrimeNumber

맵 리듀스 모델을 사용하여 프로그램을 작성하려면 원하는 연산을 맵과 리듀스 두 단계로 표현할 수 있어야 한다. 맵(또는 파티션) 단계에서는 입력을 중간 단계의 <키,값>쌍으로 표현하고, 리듀스 단계에서는 중간 단계의 <키,값>쌍을 원하는 방식으로 결합하여 최종 결과를 생성한다.
하둡은 맵과 리듀스 연산을 확장성 있고 분산 처리가 가능하게 만듦으로써 컴퓨터 클러스터에서 동작할 수 있고 연산 시간을 크게 단축시킬 수 있다.

해당 코드는 양의 정수 N이 있을 때 1에서 N사이의 소수를 찾으려고 한다. 맵 리듀스 프로그래밍 모델과 멀티 스레드를 사용하여 이 문제를 해결한다.

# PPL (병렬 처리 라이브러리)

병렬 처리 라이브러리에서 제공하는 함수들과 STL 함수의 맵 작업의 속도를 비교하는 MS 레퍼런스의 코드이다. 
여러 프로세스를 처리하는 병렬 처리 방식을 사용하는 parallel_for_each함수가 더 빠른 것을 확인할 수 있다.

병렬 처리는 대규모의 데이터를 처리할 때 유용하게 사용되는 개념이다.

# Student_grade 

학생들의 정보를 저장하고 평균과 총점, 정보를 출력할 수 있는 클래스를 구현했다.

# 2023.08.03

# Greedy Algorithm (shortest -job-first-scheduling)

은행 창구에 줄을 서서 순서를 기다리는 사람들이 있다. 하필이면 은행이 바쁜 날이라서 하나의 창구에서만 업무를 보고 있고, 대기열에 N명의 사람들이 기다리고 있다. 이들은 서로 다른 용무로 방문했기 때문에 일 처리에 필요한 시간은 사람들마다 다르다. 대기열에 기다리고 있던 모든 사람이 매우 합리적이어서 평균 대기 시간이 최소화될 수 있도록 대기 순서를 다시 정하는 것에 동의했다. 그래서 이제 대기 순서를 어ᄄᅠᇂ게 바꿔야 하는지를 결정해야 한다.

일 처리 시간 		8 1 2 4 9 2 3 5
기다려야 하는 시간  0 8 9 11 15 24 26 29
평균 대기 시간 15.25

평균 대기 시간을 최소화하는 것이 목표이기 때문에 가능한 많은 사람의 대기 시간을 줄일 수 있는 방법을 찾아야 한다. 모든 사람의 대기 시간을 줄이려면 일 처리가 가장 빨리 끝나는 사람을 맨 앞에 세워야 한다. 이러한 방식을 반복하면 다음과 같이 재정렬할 수 있다.

일 처리 시간1 2 2 3 4 5 8 9 기다려야 하는 시간
0 1 3 5 8 12 17 25
평균 대기 시간 8.875

# Fractional_kanpsack_problem (분할 가능 배낭 문제)

0-1 배낭 문제라고도 부르는 일반 배낭 문제는 NP-완전 문제로 알려져 있어서 다항 시간 솔루션을 사용할 수 없다. 그러나 0-1배낭 문제를 조금 변경한 분할 가능 배낭 문제는 그리디 방식으로 해결할 수 있다. 이 두 가지 문제를 살펴보면서 문제 정의의 작은 차이가 문제 해결 방법에 큰 변화를 가져올 수 있다는 것을 알 수 있다.

# 
<0-1배낭 문제>

물건들의 집합 O={O1,O2,O3...,On)이 있고, 여기서 I번째 물건 Oi의 무게는 Wi이고 가격은 Vi이다. 그리고 최대 무게를 T까지 견딜 수 있는 가방이 하나 주어진다. 이제 물건들을 가방에 담아야 하는데, 가방에 넣은 물건들의 가격 합이 최대가 되도록 물건을 선택하려 한다. 단, 물건들의 무게 합이 T를 넘지 않아야 한다.

배낭 문제는 NP-완전 문제로 알려져 있고, 이 문제에 대한 다항 시간 솔루션은 알려져 있지 않다. 결과적으로 모든 가능한 조합을 조사하여 무게가 T를 넘지 않는 가장 높은 가격을 찾아내야 한다. 
#
<분할 가능 배낭 문제>

이번에는 앞서 설명한 일반 배낭 문제를 조금 바꿔본다. 즉, 주어진 물건을 원하는 형태로 얼마든지 분할할 수 있고, 각 물건의 일부분만을 배낭에 담을 수 있다고 가정한다. 실생활의 예를 들면, 상인이 기름,곡물,밀가루와 같은 품목을 다룬다고 생각하면 된다. 이 경우 각 품목을 원하는 양만큼 덜어내서 배낭에 담을 수 있다.

# interval_scheduling_solution(작업 스케줄링 문제)

각각의 작업은 ID로 구분되고, 특정 시간 시작 시간과 종료 시간 사이에만 수행할 수 있다. 정해진 시간 안에 최대한 많은 수의 작업을 완료하는 것이 목표이다. 이 경우 어떤 작업을, 어떤 순서로 수행해야 할까? 특정 시점에 오직 하나의 작업만 수행할 수 있다.

1.각각의 작업은 고유한 ID, 시작 시간, 종료 시간을 가진다. 이러한 작업을 표현할 구조체를 생성한다.

2.N개의 작업을 포함하는 std::list를 생성한다. 각 작업은 1부터 N까지의 고유한 ID를 가진다. 시작 시간과 종료 시간은 임의의 정수로 설정한다.

3.다음과 같은 방식으로 스케줄링 함수를 작성한다.


  a.종료 시간을 기준으로 전체 작업 리스트를 정렬한다.

  b.그리디 방식으로 가장 빠른 종료 시간을 갖는 작업을 선택한다.

  c.현재 선택된 작업과 시간이 겹치는 작업은 모두 제거한다. 즉, 현재 작업 종료 시간보다 먼저 시작하는 작업은 제거한다.

  d.리스트에 작업이 남아 있다면 b로 이동한다. 그렇지 않으면 선택된 작업들로 구성된 벡터를 반환한다.

# MST (Minimum Spanning Tree)

모든 문제에 그리디 방식을 적용할 수 있는 것은 아니다. 최적 부분 구조와 그리디 선택이라는 두 가지 속성을 모두 갖는 문제만 그리디 접근 방식으로 최적의 솔루션을 구할 수 있다.

*최적 부분 구조: 주어진 문제 p에 대한 최적의 솔루션이 p의 부분 문제들의 최적의 솔루션으로 구성될 경우, 문제 p가 최적의 부분 구조를 갖는다고 말한다.

*그리디 선택: 주어진 문제 P에 대한 지역적 최적 솔루션을 반복적으로 선택하여 전체 최적 솔루션을 구할 수 있는 경우, 문제 p가 그리디 선택 속성을 갖는다고 말한다.

최적 부분 구조와 그리디 선택 속성에 대해 이해하기 위해, 크루스칼 최소 신장 트리 알고리즘에 대해 알아본다.

최소 신장 트리는 다음과 같이 정의할 수 있다. “정점(vertex)의 집합 V와 가중치를 갖는 에지(Edge)의 집합E로 구성된 그래프 G=<V,E>가 주어질 때, 모든 정점을 연결하고 연결된 에지의 가중치 합이 최소인 트리 T를 구하시오.”

실생활에서 찾아볼 수 있는 MST 문제의 예로 상수도관 네트워크 또는 도로 네트워크 설계가 있다. 상수도관 네트워크 설계의 경우, 모든 사람에게 수돗물이 전달되어야 하고 전체 상수도관의 길이는 최소가 되는 것이 좋다. 도로 네트워크를 설계할 때는 모든 필요한 지점에 도로가 연결되어야 하고 도로의 전체 길이는 최소가 되는 것을 목표로 한다. 

최소 신장 트리T를 구하는 방법은 다음과 같다.

1.그래프 G의 모든 에지를 최소 힙 H에 추가한다.

2.H로부터 에지 e를 하나 꺼낸다. 당연히 e는 모든 에지 중에서 가장 가중치가 작은 에지이다.

3.e의 양 끝 정점이 이미 T에 있을 경우, e로 인해 T에서 사이클이 발생할 수 있다. 그러므로 이런 경우에는 e를 버리고 2단계로 이동한다.

4.최소 신장 트리 T에 e를 추가하고, 2단계로 이동한다.

이 알고리즘은 2단계부터 4단계까지를 반복하면서 가장 작은 가중치의 에지를 찾고, 이 에지에 의해 사이클이 발생하지 않으면 해당 에지와 양 끝 정점을 최종 솔루션에 추가한다. 이렇게 선택된 에지와 정점은 최소 신장 트리를 구성한다. 이 알고리즘은 매 반복마다 최소 에지 가중치를 선택하기 때문에 그리디 방식이라고 할 수 있다. 이 알고리즘을 크루스칼 최소 신장 트리 알고리즘이라고 한다.

최적 부분 구조: 귀류법을 사용하여 최적 부분 구조 속성을 증명해본다. 이를 위해 MST 문제가 최적 부분 구조 속성을 가지지 않는다고 가정한다. 즉, 최소 신장 트리가 더 작은 최소 신장 트리의 집합으로 구성되지 않는다고 가정한다.

1. 그래프 G의 정점으로 구성된 최소 신장 트리 T가 있다고 가정한다. T에서 에지 e를 하나 선택하여 제거한다. e를 제거하면 T가 더 작은 트리인 T1과 T2로 나눠진다.

2.MST 문제가 최적 부분 구조 속성을 갖지 않는다고 가정했으므로 T1보다 작은 가중치를 갖는 신장 트리 T1'이 존재해야 한다. 이 신장 트리 T1'과 T2를 에지 e로 연결한 새로운 신장 트리를 T'이라고 한다.

3. T'의 가중치가 T의 가중치보다 작으므로 처음에 T가 최소 신장 트리라고 가정했던 사실이 틀리게 된다.

정리하면 최소 신장 트리 T의 부분 구조인 T'의 가중치가 더 작으므로 T'도 신장트리라고 할 수 있다. 따라서 T는 더 작은 신장트리로 구성된다고 할 수 있다. 따라서 처음 가설이 틀린 것이다.

그리디 선택: MST 문제가 그리디 선택 속성을 갖는다면 정점 v와 연결된 에지 중에서 최소 가중치 에지는 반드시 최소 신장 트리 T에 속해야 한다. 귀류법을 사용하여 이 가설을 증명할 수 있다.

1.정점 v에 연결되어 있는 에지 중에서 최소 가중치를 갖는 에지를 (u,v)라고 가정한다. 

2.만약 (u,v)가 T에 속하지 않는다면 T는 v와 연결되어 있는 다른 에지를 포함해야 한다. 이 에지를 (x,v)라고 한다. (u,v)가 최소 가중치 에지이기 때문에, (x,v)는 (u,v)의 가중치보다 커야 한다. 

3.T에서 (x,v)를 제거하고 (u,v)를 추가할 경우 전체 가중치가 더 작은 트리를 얻을 수 있다. 이는 T가 최소 신장 트리라는 가정에 위배된다. 따라서 그리디 선택 속성을 만족한다.

이 알고리즘을 구현하려면 그래프 에지 정보를 저장할 자료 구조가 필요하고, 새로운 에지를 추가할 때 사이클이 발생하는지를 판단하는 기능이 필요하다. 이 문제는 디스조인트-셋 자료 구조를 사용하여 해결할 수 있다.

# 2023.08.08

# copy_jpg (using c style file input-output)

C 언어의 함수인 fopen_s를 사용하여 jpg파일을 복사하는 코드이다.

# 2023.08.09

# Linux File-System upgrade version
이전에 공부했던 N-항 트리를 이용한 리눅스 파일 시스템에서 부모 노드의 주소를 저장하여 이전 노드로 디렉토리를 움직일 수 있다. 
또한 현재 노드가 소유한 모든 디렉토리를 보여주는 all기능도 추가했다.

# Graph Coloring

그래프 컬러링은 실생활의 다양한 문제에 적용할 수 있다. 택시 예약 스케줄 작성, 스도쿠 퍼즐 풀기, 시험 시간표 작성 등 그래프로 모델링한 후 컬러링 문제 형태로 해결할 수 있다. 그러나 그래프 컬러링에 필요한 최소 개수의 색상 수를 찾는 것은 NP-완전 문제로 알려져 있다. 다만 문제를 조금 변경함으로써 시간 복잡도를 크게 변경할 수 있다.

스도쿠 문제는 다음과 같이 해결할 수 있다. 

1.각각의 셀을 그래프 정점으로 표현한다.

2.같은 행, 같은 열, 3*3 블록 안에 있는 모든 정점끼리 에지를 연결한다.

3.생성된 그래프 G에 대해 그래프 컬러링을 수행하면 입력 스도쿠 퍼즐의 해답을 구할 수 있다.

그래프 컬러링의 평가는 얼마나 적은 수의 색상을 사용했는가에 의해 결정된다. 가능한 적은 수의 색상을 사용하는 최적의 그래프 컬러링 방법 찾기는 
NP-완전 문제이지만, 그리디 방식이 유용한 근사치를 제공하곤 한다. 예를 들어 컴파일러를 설계할 경우, 컴파일하는 프로그램의 변수에 CPU 레지스터를 할당하기 위해 그래프 컬러링이 사용된다. 몇몇 휴리스틱 방법과 함께 그리디 방식의 컬러링 알고리즘을 사용하면 “충분히 괜찮은” 솔루션을 얻을 수 있으며, 이러한 방식은 컴파일러의 빠른 동작이 필요한 상황에서 바람직하다.

# Normal_Tree (색다른 버전의 트리)

이전에 공부했던 Tree와 살짝 다른 구조를 가지고 있다.

# 2023.08.21

# BehaviorTree

언리얼 엔진의 BehaviorTree를 간단하게 구현한 예제이다. Selector, Sequence, Decorator, ActionNode 등이 있고 간단한 처리가 가능하다. 

N항 트리 구조를 사용했다.

# DungeonGenerator

N항 트리를 사용한 리눅스 파일 시스템 코드를 변형하여 TXT_RPG에 사용할 DungeonGenerator를 구성했다. 

# Welsh-Powell algorithm (웰시 포웰 알고리즘 - 그래프 컬러링)

앞서 살펴본 그래프 컬러링의 성능을 조금 향상시키는 방법이 있다. 차수가 높은 정점부터 차례대로 그래프 컬러링을 수행하는 것이다. 이를 웰시 포웰 알고리즘이라고 한다. 

1.모든 정점을 차수에 대한 내림차순으로 정렬하고 배열에 저장한다. 

2.정렬된 배열에서 색상이 지정되지 않은 첫 번째 정점을 선택하고, 이 정점과 연결된 모든 정점을 조사하여 아직 사용되지 않은 색상을 해당 정점에 지정한다. 이 색상을 C라고 지정한다. 

3.정렬된 배열에서 색상이 지정되지 않은 정점을 모두 찾고, 만약 이 정점의 이웃이 C 색상을 가지고 있지 않다면 해당 정점에 C를 부여한다.

4.배열에 색상이 지정되지 않은 정점이 남아 있다면 2단계로 이동한다. 남아 있는 정점이 없다면 종료한다. 이때까지 정점에 지정된 색상이 최종 결과다.

차수는 정점에서 연결된 선의 개수이다.

<구현 솔루션>

1.먼저 에지를 표현하는 Edge 구조체와 에지 리스트를 사용하여 그래프 구조를 표현하는 Graph클래스를 작성해야 한다. 

2.웰시 포웰 그래프 컬러링 알고리즘을 구현한 함수를 작성한다. 이 함수는 각 정점의 색상을 벡터로 반환하도록 한다. 이 벡터의 I번째 원소는 I번째에 해당하는 정점의 색상을 나타낸다. 

일반적인 그래프 컬러링 알고리즘보다 성능이 좋다. 이유는 정점의 차수를 고려하지 않고 차례대로 색깔을 검사하는 것 보다 차수가 큰 정점부터 색깔을 조사하는 것이 더 효율적이기
때문이다.

# BFS(Breadth_First_Search) 너비 우선 탐색

그래프에서 너비 우선 탐색은 시작 정점을 경계에 추가하는 것으로 시작한다. 경계는 이전에 방문했던 정점들에 의해 구성된다. 그리고 현재 경계에 인접한 정점을 반복적으로 탐색한다.

BFS는 모든 정점에 대해 자식 정점을 손자 정점보다 먼저 방문한다는 점이 중요한 특징이다. BFS를 구현할 경우, 보통 경게를 별도의 자료 구조를 만들어서 명시적으로 사용하지는 않는다. 대신 정점 ID를 큐에 저장하여 시작 정점과 가까운 정점을 멀리 있는 정점보다 먼저 방문할 수 있도록 구현한다.

BFS의 시간 복잡도는 O(V+E)이다. V는 정점의 개수이고, E는 에지의 개수이다.

# DFS(Depth_First_Search) 깊이 우선 탐색

너비 우선 탐색이 시작 정점에서 시작하여 점차 탐색 범위를 넓혀 나가는 방식이라면, 깊이 우선 탐색은 시작 정점에서 시작하여 특별 경로를 따라 가능한 멀리 있는 정점을 재귀적으로 먼저 방문하는 방식이다. 그리고 더 방문할 정점이 없어지면 다른 경로를 찾아 다시 멀어지는 방향으로 탐색을 반복한다. 이러한 그래프 탐색 방법을 백트래킹이라고 한다. DFS는 큐 대신 스택을 사용한다. 스택은 후입선출 속성을 가지고 있기 때문에 현재 정점과 인접한 정점들을 재귀적으로 이동하면서 방문할 때 사용하기에 적합한 자료 구조이다.

BFS와 DFS의 시간 복잡도는 모두 O(V+E)이다. 그러나 두 알고리즘에는 몇 가지 큰 차이가 있다. 다음은 BFS와 DFS의 두드러진 차이점과 적합한 사용 시나리오를 정리한 것이다. 

*BFS는 시작 정점에서 가까운 정점을 찾는 데 적합하고, DFS는 대체로 시작 정점에서 멀리 있는 정점을 찾을 때 적합하다.

*BFS에서 특정 정점을 방문할 경우, 시작 정점에서 해당 정점까지의 최단 거리 경로가 보장된다. 그러나 DFS는 최단 경로를 보장하지 않는다. 이러한 속성 때문에 단일-시작 또는 다중-시작 최단 경로 알고리즘이 BFS 알고리즘을 조금 변경하여 사용하고 있다.

*BFS는 현재 경계에 인접한 모든 정점을 방문하므로 BFS에 의해 생성된 검색 트리는 짧고 넓은 편이며, 많은 메모리를 필요로 한다. 반면에 DFS에 의해 생성된 검색 트리는 길고 좁은 편이며 상대적으로 적은 메모리를 필요로 한다.

# 2023.08.22

# Bipartite_Graph discrimination (이분 그래프 판별 코드)

이분 그래프는 정점을 두 개의 집합으로 나눌 수 있는 그래프이다. 이때 그래프의 모든 에지는 서로 다른 집합에 속한 정점끼리 연결되어야 한다. 이분 그래프는 실생활의 여러 문제를 모델링할 수 있다. 예를 들어 학생 목록과 수업 목록이 있을 때, 학생들이 어떤 수업을 수강하고 있는지를 이분 그래프로 표현할 수 있다. 즉, 학생 정점에서 수업 과목 정점으로 에지가 연결되어 있으면 해당 학생이 이 수업을 수강하고 있다는 의미이다. 학생에서 학생으로, 또는 수업에서 다른 수업으로 연결되는 에지는 있을 수 없다. 따라서 이분 그래프로 표현하기 적합하다.

특정 학생이 신청한 두 개의 수업이 같은 시간대에 중복되지 않도록 수강 계획을 만드는 데 사용할 수 있다. 예를 들어 유미가 수학과 영어 과목을 수강했다면 두 수업이 같은 시간대에 진행되면 안된다. 수업 시간표 작성 시 이러한 충돌을 최소화하는 작업은 그래프에서 최대 유량 문제를 풀어서 달성할 수 있다. 최대 유량 문제에 대해서는 몇 가지 표준 알고리즘이 알려져 있다. 포드-풀커슨 알고리즘, 디닉 알고리즘, 푸시-리레이블 알고리즘이 그 예이다. 그러나 이들 알고리즘은 꽤 복잡하여 지금은 다루지 않는다.

넷플릭스나 유튜브같은 대형 비디오 스트리밍 플랫폼에서 제공되는 영화 목록과 시청자 사이의 관계도 이분 그래프를 사용하여 모델링할 수 있다. 즉, 사용자가 특정 영화를 시청했다면 에지를 연결하는 방식으로 사용자의 시청 기록을 관리할 수 있다.

이분 그래프에 대해 흥미로운 사실은 최대 매칭 또는 최소 정점 커버 문제처럼 일반 그래프에서는 NP-완전인 문제들이 이분 그래프에서는 다항시간으로 풀 수 있다는 사실이다. 따라서 주어진 그래프가 이분인지 아닌지를 알아내는 것은 매우 중요하다. 

다음은 주어진 그래프가 이분 그래프인지 확인하는 c++프로그램의 아이디어이다. 이분 그래프를 판별하는 알고리즘은 DFS를 조금 변형하여 만들 수 있다.

1. 1번 정점부터 DFS를 시작한다고 가정한다. 그러므로 1번 정점을 스택에 추가한다.

2.만약 스택에 방문하지 않은 정점이 남아 있으면 스택에서 정점을 하나 꺼내고 이를 현재 정점으로 설정한다.

3.이전 정점에 할당된 색상이 ‘검은색’이면, 현재 정점에 ‘빨간색’을 할당한다. 반대로 이전 정점에 할당된 색상이 ‘빨간색’이면 현재 정점에 ‘검은색’을 할당한다.

4.현재 정점과 인접한 정점들 중에서 아직 방문하지 않은 정점들을 스택에 넣고, 현재 정점을 방문한 것으로 설정한다.

5.모든 정점에 색상이 지정될 때까지 2~4단계를 반복한다. 알고리즘 종료 시 모든 정점에 색상이 칠해져 있다면 이 그래프는 이분 그래프이다.

6.만약 탐색을 진행하다가 만나게 된 정점이 이미 방문한 정점이고, 이 정점의 색상이 현재 할당할 색상과 다른 색상이면, 알고리즘을 종료하고, 해당 그래프가 이분 그래프가 아니라고 판별한다.

즉 이분 그래프가 주어졌다면 두 집합을 번갈아가며 다른 색으로 모두 칠할 수 있기에 이분 그래프로 판별하고, 만약 같은 색상으로 할당된 인접한 정점을 만나면 이분 그래프가 아니라고 판별한다.

# Prim MST Algorithm (프림 최소 신장 트리)

MST 문제를 다시 정의해보면 “정점 집합 V와 가중치를 갖는 에지 집합 E로 구성된 그래프 G=<V,E>가 주어질 때 모든 정점을 연결하고 연결된 에지의 가중치 합이 최소인 트리 T를 구한다.”

크루스칼 알고리즘은 그래프의 모든 에지를 최소 힙에 추가하고, 사이클을 만들지 않는 최소 가중치의 에지를 이용하여 MST를 구성한다.

프림 알고리즘은 BFS의 동작 방식과 유사하다. 프림 알고리즘은 먼저 시작 정점을 이용하여 경계를 구성한다. 경계는 이전에 방문했던 정점들에 의해 구성되며, 현재 경계에 인접한 정점을 반복적으로 탐색한다. 이때 프림 알고리즘은 경계를 관통하는 에지 중에서 가장 가중치가 작은 에지를 선택하고, 이 에지에 연결된 정점을 방문한다. 

프림 알고리즘을 구현하려면 그래프의 각 정점에 경계로부터의 거리(distance) 정보를 기록해야 한다.

1.모든 정점의 거리 값을 무한대로 초기화한다. 시작 정점에서 자기 자신까지의 거리는 0이므로 시작 정점의 거리 값은 0으로 설정한다. 그리고 모든 거리 값을 최소 힙 H에 추가한다.

2.최소 힙 H로부터 정점을 하나 꺼낸다. 이 정점을 U라고 하면, 정점 U는 경계에서 가장 가까이 있는 정점이다. 이 정점을 포함하도록 경계를 새로 설정한다. 

3.U와 인접한 모든 정점 V에 대해 만약 V의 거리 값이(U,V)의 에지 가중치보다 크면 V의 거리 값을 (U,V)의 에지 가중치로 설정한다. 처음에는 거리 값이 모두 무한대이기 때문에 시작 정점의 인접 정점들의 거리 값이 가중치로 초기화된다. 이 과정을 정점 U에 안착(settle)했다고 한다. 

4.방문하지 않은 정점이 남아 있다면 2단계로 이동한다.

5.모든 정점에 대해 안착한 후 최종 MST가 생성된다.
프림 알고리즘(Prim's Algorithm)은 최소 비용 신장 트리(Minimum Spanning Tree)를 찾는 그리디 알고리즘 중 하나입니다. 최소 비용 신장 트리란 그래프 내의 모든 정점을 포함하면서 간선의 가중치 합이 최소인 트리를 말합니다. 이 알고리즘에서 거리 값이 사용되는 이유는 다음과 같습니다.

프림 알고리즘의 목적은 주어진 연결 그래프에서 최소 비용 신장 트리를 구성하는 것입니다. 알고리즘이 진행되면서 트리가 점진적으로 확장되며, 트리 내의 정점들과 트리 밖의 정점들 사이에 새로운 간선을 연결하는 방식으로 진행됩니다. 이때, 선택되지 않은 정점들 중에서 최소 비용의 간선을 선택하여 트리에 추가하는 것이 핵심적인 아이디어입니다.

거리 값이 사용되는 이유는 다음과 같다:

정점의 선택: 알고리즘은 현재 트리에 속한 정점과 트리에 속하지 않은 정점 간의 간선 중 가장 작은 가중치를 가진 간선을 선택하여 트리에 연결다. 이때, 간선의 가중치를 거리 값으로 볼 수 있다. 가중치가 작을수록 두 정점 간의 거리가 짧다고 볼 수 있다.

트리 내 간선의 갱신: 이미 트리에 속한 정점과 트리에 속하지 않은 정점을 연결하는 간선 중에서 더 작은 가중치를 가진 간선이 나타날 수 있다. 이 경우, 새로운 간선으로 갱신하여 더 작은 거리 값을 사용하게 된다.

그래프 내에서의 최소 거리: 프림 알고리즘은 선택되지 않은 정점들 중에서 최소 비용의 간선을 찾아 트리에 추가한다. 이를 통해 최소 비용 신장 트리가 생성되는데, 이는 그래프 내의 정점들 간의 최소 거리를 고려한 결과라고 볼 수 있다.

종합적으로, 프림 알고리즘에서 거리 값은 정점 간의 연결을 결정하고 최소 비용 신장 트리를 형성하는 데 사용되는 중요한 개념이다.

# 2023.08.23

# Dijkstra Algorithm (최소 비용 경로)

“주어진 그래프 G=<V,E>가 있다. 여기서 V는 정점의 집합이고, E는 에지의 집합이다. 각각의 에지는 가중치를 가지고 있다. 시작 정점과 목적 정점이 주어질 때, 시작 정점에서 목적 정점까지 이어지는 최소 비용 경로를 구하시오.”

다익스트라 알고리즘은 음수 가중치가 없는 그래프에서 동작하는 최단 경로 탐색 알고리즘으로 프림의 MST 알고리즘을 약간 변형한 형태이다. 다익스트라 알고리즘이 프림 알고리즘과 다른 두 가지 차이점은 다음과 같다.

*프림 알고리즘은 경계로부터 최소 거리를 정점의 거리 값으로 설정하지만, 다익스트라 알고리즘은 시작 정점으로부터 각 정점까지의 전체 거리를 사용한다. 

*다익스트라 알고리즘은 목적 정점이 나타나면 종료하지만 프림 알고리즘은 모든 정점을 방문해야 종료한다.

다익스트라 알고리즘의 동작은 다음과 같다.

1.모든 정점의 거리 값을 무한대로 초기화한다. 시작 정점에서 자기 자신까지의 거리는 0이므로 시작 정점의 거리 값은 0으로 설정한다. 그리고 모든 거리 값을 최소 힙 H에 추가한다.

2.최소 힙 H로부터 정점을 하나 꺼낸다. 이 정점을 U라고 하면, 정점 U는 시작 정점에서 가장 가까운 정점이다. 만약 U가 목적 정점이면 최단 경로를 찾은 것이므로 알고리즘을 종료한다.

3.U와 인접한 모든 정점 V에 대해 만약 V의 거리 값이 (U의 거리값+ (U,V)의 가중치)보다 크면 V까지 다다르는 더 짧은 경로를 찾은 것으로 볼 수 있다. 그러므로 V의 거리 값을 (U의 거리 값+(U,V)에지 가중치)값으로 설정한다. 이러한 과정을 정점 U에 안착했다고 한다.

4.방문하지 않은 정점이 남아 있다면 2단계로 이동한다. 

5.최소 힙 H로부터 꺼낸 정점이 목적 정점이면 알고리즘을 종료한다.

다익스트라 알고리즘을 피보나치 최소 힙을 사용하여 구현한 시간 복잡도는 
O(E+VlogV)이다.

# USA_NY_shortest_path (다익스트라 알고리즘을 이용한 뉴욕 도로망 최소 비용 거리)

다익스트라 알고리즘을 사용하여 뉴욕시 도로망에서 최단 거리 경로를 찾는 프로그램을 만들어 본다. 이번 실습 문제에서 사용할 도로망 그래프는 264,326개의 정점과 733,846개의 방향 에지로 구성되고, 에지 가중치는 두 정점 사이의 유클리디언 거리로 정의된다. 

# Bellman_Ford_Algorithm(벨만 포드 알고리즘)

음수 가중치가 있는 그래프를 다룰 때에는 벨만-포드 알고리즘을 사용할 수 있다. 이 방법은 그래프의 모든 에지에 대해 다익스트라의 그리디 선택 방법을 
(V-1)번 반복하여 점진적으로 최단 거리를 찾는다. 여기서 V는 정점의 개수를 나타낸다. 벨만-포드 알고리즘은 다익스트라 알고리즘보다 높은 점근적 시간 복잡도를 가지지만, 다익스트라 알고리즘이 잘못 해석할 수 있는 그래프에 대해서도 정확한 결과를 제공한다.

# Greedy_Robot using Bellman-Ford Algorithm

장애물 코스에서 효율적인 경로를 찾는 길 찾기 로봇을 개발하려고 한다. 테스트를 위해 체스판 같은 정사각형 격자 형태의 코스를 몇 개 만들었다. 로봇은 어떤 장애물이든 통과할 수 있지만, 이 경우 많은 전력을 소모하게 된다. 로봇은 격자의 좌측 상단에서 출발하고, 동서남북 네 방향으로 이동할 수 있다. 로봇이 목적지에 도착할 때 남아있는 에너지가 최대가 되도록 경로를 선택하는 알고리즘을 구현해야 한다.

이러한 탐색을 하려면 많은 에너지를 필요로 하기 때문에 코스 곳곳에 충전소를 설치하였고, 로봇은 여기서 스스로 충전할 수 있다. 그러나 이 로봇은 꽤나 욕심이 많아서 충전소를 재방문할 수 있는 경로가 있다면 몇 번이고 다시 방문하여 충전을 반복하게 되고, 결국에는 과충전되어 폭발할 수 있다. 이 때문에 로봇이 충전소에 재방문할 것인지를 예측하여 과충전 같은 문제를 미연에 방지해야 한다.

*입력

첫 번째 줄은 정수 하나가 있으며, 이를 N이라고 한다. N은 코스의 가로 및 세로 크기를 나타낸다. 

그 다음에 나타나는 (N^2-1)줄은 방향을 가리키는 directions 문자열과 전력 소모량을 나타내는 power 정수 값으로 구성된다. 각각의 줄은 격자 모양 코스의 맨 처음 해의 왼쪽부터 오른쪽 방향으로 나타나는 셀(격자)의 정보를 나타낸다. 예를 들어 3x3 크기의 격자 코스인 경우, [0,0]->[0,1]->[0,2]->[1,0]->
[1,1]->[1,2]->[2,0]->[2,1] 순서로 셀 정보가 나타난다. 맨 마지막 셀은 목적지 이므로 셀 이동 정보가 없다.

direction문자열은 {'N','S','E','W'} 네 문자 중에서 0~3개를 이용하여 구성된다. 이 문자열은 로봇이 특정 지점에서 방문할 수 있는 셀 방향을 나타낸다. 즉 'N‘은 북쪽, ’S'는 남쪽, ‘E'는 동쪽, ’W'는 서쪽을 의미한다. 예를 들어 directions 문자열이 "SW"이면 로봇이 남쪽 또는 서쪽으로 이동할 수 있다. power는 셀을 이동할 때 필요한 전력 소비량을 나타낸다. p가 양수이면 현재 셀에 충전소가 있음을 나타낸다.

*출력

로봇이 코스의 우측 하단 셀에 도달할 때 가질 수 있는 최대 전력량을 출력하되, 시작시 전력량을 기준으로 상대적인 전력량을 출력한다. 예를 들어 로봇이 코스를 시작시 전력량보다 10만큼 더 많은 상태로 빠져나올 수 있다면 10을 출력한다. 만약 시작 시 전력량보다 10만큼 적은 상태로 빠져나올 수 있다면
-10을 출력한다. 

만약 탐색중에 로봇이 폭발할 경우 “탐색 중단” 문자열을 출력한다.

*문제 해결 가이드라인

벨만-포드 알고리즘에서 음수 사이클을 감지하는 알고리즘 이상의 것은 필요하지 않다.

입력을 해석하여 그래프를 구성하는 기능이 필요하다.

반드시 2차원 격자 형태의 코스를 만들 필요는 없다.

벨만-포드 알고리즘은 다익스트라 알고리즘이 제대로 작동하지 않는 그래프에 대해서도 정확한 결과를 제공하기 때문에 더 광범위하게 사용할 수 있다. 그러나 주어진 그래프가 음수 에지 가중치를 가지고 있지 않다면 그리디 방식을 사용하는 다익스트라 알고리즘이 더욱 효율적이다.

V번 이상의 반복에서 거리 값이 업데이트되는 경우에는 음의 사이클이 존재한다고 볼 수 있다. 각 반복마다 시작 정점부터 각 정점까지의 최단 경로에 최소 한 개 이상의 에지가 포함될 수
있기 때문에(최종 최단 거리가 아직 구해지지 않은 경우) 최대 V-1개의 에지가 경로에 포함될 수 있다. 따라서 V번 이상의 반복이 필요한 경우라면 V개 이상의 에지가 포함된다는 말인데
정점 개수보다 에지 개수가 많을 수는 없다. 따라서 중복 방문(사이클)이다.

# Johnson's Algorithm (벨만 포드와 다익스트라의 합성)

다익스트라 알고리즘과 벨만-포드 알고리즘의 효율성을 활용함과 동시에 음수 가중치를 갖는 그래프에 대해서도 올바른 결과를 생성할 수 있다. 존슨 알고리즘은 상당히 새로운 접근 방법을 사용한다. 이 알고리즘은 음수 가중치에 대한 다익스트라 알고리즘의 한계를 극복하기 위해 전체 에지 가중치를 음수가 아닌 형태로 변환한다. 이러한 작업은 벨만-포드 알고리즘과 적절한 수학 논리를 결합하여 이루어진다. 

존슨 알고리즘의 첫 번째 단계는 그래프에 새로운 ‘더미(dummy)' 정점을 추가하는 것이다. 그리고 이 더미 정점과 나머지 모든 정점 사이에 가중치가 0인 에지를 연결한다. 이후 벨만-포드 알고리즘을 이용하여 더미 정점과 나머지 정점들 사이의 최단 경로를 찾고, 나중에 사용하기 위해 각 정점까지의 최단 거리를 기록한다.

더미 정점 추가에 대해 좀 더 알아본다. 더미 정점과 나머지 모든 정점 사이에 가중치가 0인 에지를 연결했기 때문에 모든 최단 거리 값은 0보다 클 수 없다. 또한 그래프의 모든 정점에 대한 연결을 통해 거리 값이 모든 가능한 순회 경로에서 일정한 관계를 유지할 수 있으며 이로 인해 에지 가중치와 최단 거리의 합 연산이 간단해질 수 있다. 즉, 이동 경로상의 연속한 정점에 대해서 거리 값 연산이 서로 상쇄되어, 결국 전체 합은 첫 번째 정점과 마지막 정점의 거리 값 차와 같다.

존슨 알고리즘은 가중치를 다음 수식을 통해서 변환한다.

w(uv) = w(uv) + d[s,u] - d[s,v]

위 수식을 사용하면 telescope 속성을 사용할 수 있어 최종 수식이 짧아진다. 또한 모든 에지의 가중치를 0 이상의 값으로 변경할 수 있다.

벨만-포드 알고리즘은 d[s,u] + w(u,v) >= d[s,v]를 만족하기 때문에 변환된 가중치는 음수가 될 수 없다. d[s,v]가 0이기 때문이다. 

즉 원래의 최단 경로 순서는 그대로 유지한 채, 음이 아닌 가중치로 구성된 그래프가 만들어진다. 이제 새로운 가중치를 갖는 그래프의 각 정점에서 다익스트라 알고리즘을 적용하여 모든 정점 쌍 사이의 최단 거리를 구할 수 있다.
