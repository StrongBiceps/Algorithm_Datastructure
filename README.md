# Algorithm_Datastructure

# 2023.08.02

# Map_Reduce using STL (STL을 이용)

맵은 컨테이너 C를 입력으로 받아, 컨테이너의 모든 원소에 함수 f(x)를 적용하는 것이다. 예를 들어 f(x)=x^2함수를 사용할 경우에 대한 맵 연산을 다음에 나타낸다.
1 2 3 4 5 6 7
->1 4 9 16 25 36 49

리듀스는 컨테이너 C의 모든 원소 x에 함수 f(acc,x)를 적용하여 하나의 값으로 축약하는 연산이다. 예를 들어 f(acc,x)=acc+x 함수를 사용할 경우에 대한 리듀스 연산의 예를 다음에 나타낸다. 
1 2 3 4 5 6 7
->28

c++ 표준 라이브러리는 맵과 리듀스 연산을 std::transform()과
std::accumulate함수로 제공한다. c++17에서는 std::reduce()도 제공한다.
accumulate()는 기본적으로 누적 연산을 수행하기 때문에 리듀스 연산의 제한된 형태라고 볼 수 있다. c++17을 지원하는 최신 컴파일러에서는 더 일반적이며 병렬 처리도 지원하는 reduce()를 사용할 수 있다.

# Map_Reduce_PrimeNumber

맵 리듀스 모델을 사용하여 프로그램을 작성하려면 원하는 연산을 맵과 리듀스 두 단계로 표현할 수 있어야 한다. 맵(또는 파티션) 단계에서는 입력을 중간 단계의 <키,값>쌍으로 표현하고, 리듀스 단계에서는 중간 단계의 <키,값>쌍을 원하는 방식으로 결합하여 최종 결과를 생성한다.
하둡은 맵과 리듀스 연산을 확장성 있고 분산 처리가 가능하게 만듦으로써 컴퓨터 클러스터에서 동작할 수 있고 연산 시간을 크게 단축시킬 수 있다.

해당 코드는 양의 정수 N이 있을 때 1에서 N사이의 소수를 찾으려고 한다. 맵 리듀스 프로그래밍 모델과 멀티 스레드를 사용하여 이 문제를 해결한다.

# PPL (병렬 처리 라이브러리)

병렬 처리 라이브러리에서 제공하는 함수들과 STL 함수의 맵 작업의 속도를 비교하는 MS 레퍼런스의 코드이다. 
여러 프로세스를 처리하는 병렬 처리 방식을 사용하는 parallel_for_each함수가 더 빠른 것을 확인할 수 있다.

병렬 처리는 대규모의 데이터를 처리할 때 유용하게 사용되는 개념이다.

# Student_grade 

학생들의 정보를 저장하고 평균과 총점, 정보를 출력할 수 있는 클래스를 구현했다.

# 2023.08.03

# Greedy Algorithm (shortest -job-first-scheduling)

은행 창구에 줄을 서서 순서를 기다리는 사람들이 있다. 하필이면 은행이 바쁜 날이라서 하나의 창구에서만 업무를 보고 있고, 대기열에 N명의 사람들이 기다리고 있다. 이들은 서로 다른 용무로 방문했기 때문에 일 처리에 필요한 시간은 사람들마다 다르다. 대기열에 기다리고 있던 모든 사람이 매우 합리적이어서 평균 대기 시간이 최소화될 수 있도록 대기 순서를 다시 정하는 것에 동의했다. 그래서 이제 대기 순서를 어ᄄᅠᇂ게 바꿔야 하는지를 결정해야 한다.

일 처리 시간 		8 1 2 4 9 2 3 5
기다려야 하는 시간  0 8 9 11 15 24 26 29
평균 대기 시간 15.25

평균 대기 시간을 최소화하는 것이 목표이기 때문에 가능한 많은 사람의 대기 시간을 줄일 수 있는 방법을 찾아야 한다. 모든 사람의 대기 시간을 줄이려면 일 처리가 가장 빨리 끝나는 사람을 맨 앞에 세워야 한다. 이러한 방식을 반복하면 다음과 같이 재정렬할 수 있다.

일 처리 시간1 2 2 3 4 5 8 9 기다려야 하는 시간
0 1 3 5 8 12 17 25
평균 대기 시간 8.875

# Fractional_kanpsack_problem (분할 가능 배낭 문제)

0-1 배낭 문제라고도 부르는 일반 배낭 문제는 NP-완전 문제로 알려져 있어서 다항 시간 솔루션을 사용할 수 없다. 그러나 0-1배낭 문제를 조금 변경한 분할 가능 배낭 문제는 그리디 방식으로 해결할 수 있다. 이 두 가지 문제를 살펴보면서 문제 정의의 작은 차이가 문제 해결 방법에 큰 변화를 가져올 수 있다는 것을 알 수 있다.

# 
<0-1배낭 문제>

물건들의 집합 O={O1,O2,O3...,On)이 있고, 여기서 I번째 물건 Oi의 무게는 Wi이고 가격은 Vi이다. 그리고 최대 무게를 T까지 견딜 수 있는 가방이 하나 주어진다. 이제 물건들을 가방에 담아야 하는데, 가방에 넣은 물건들의 가격 합이 최대가 되도록 물건을 선택하려 한다. 단, 물건들의 무게 합이 T를 넘지 않아야 한다.

배낭 문제는 NP-완전 문제로 알려져 있고, 이 문제에 대한 다항 시간 솔루션은 알려져 있지 않다. 결과적으로 모든 가능한 조합을 조사하여 무게가 T를 넘지 않는 가장 높은 가격을 찾아내야 한다. 
#
<분할 가능 배낭 문제>

이번에는 앞서 설명한 일반 배낭 문제를 조금 바꿔본다. 즉, 주어진 물건을 원하는 형태로 얼마든지 분할할 수 있고, 각 물건의 일부분만을 배낭에 담을 수 있다고 가정한다. 실생활의 예를 들면, 상인이 기름,곡물,밀가루와 같은 품목을 다룬다고 생각하면 된다. 이 경우 각 품목을 원하는 양만큼 덜어내서 배낭에 담을 수 있다.

# 작업 스케줄링 문제

각각의 작업은 ID로 구분되고, 특정 시간 시작 시간과 종료 시간 사이에만 수행할 수 있다. 정해진 시간 안에 최대한 많은 수의 작업을 완료하는 것이 목표이다. 이 경우 어떤 작업을, 어떤 순서로 수행해야 할까? 특정 시점에 오직 하나의 작업만 수행할 수 있다.

1.각각의 작업은 고유한 ID, 시작 시간, 종료 시간을 가진다. 이러한 작업을 표현할 구조체를 생성한다.
2.N개의 작업을 포함하는 std::list를 생성한다. 각 작업은 1부터 N까지의 고유한 ID를 가진다. 시작 시간과 종료 시간은 임의의 정수로 설정한다.
3.다음과 같은 방식으로 스케줄링 함수를 작성한다.

a.종료 시간을 기준으로 전체 작업 리스트를 정렬한다.
b.그리디 방식으로 가장 빠른 종료 시간을 갖는 작업을 선택한다.
c.현재 선택된 작업과 시간이 겹치는 작업은 모두 제거한다. 즉, 현재 작업 종료 시간보다 먼저 시작하는 작업은 제거한다.
d.리스트에 작업이 남아 있다면 b로 이동한다. 그렇지 않으면 선택된 작업들로 구성된 벡터를 반환한다.
